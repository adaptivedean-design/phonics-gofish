<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Go-Fish Phonics</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Firebase configuration
        const firebaseConfig = {
          apiKey: "AIzaSyAy6Qm0jlUeHad9PxHZfsh7Zz9tiLlVSMk",
          authDomain: "go-fish-2afec.firebaseapp.com",
          databaseURL: "https://go-fish-2afec-default-rtdb.firebaseio.com",
          projectId: "go-fish-2afec",
          storageBucket: "go-fish-2afec.firebasestorage.app",
          messagingSenderId: "489979746272",
          appId: "1:489979746272:web:4997e46c296f79f2117d85"
        };

        // Initialize Firebase
        if (!firebase.apps.length) {
          firebase.initializeApp(firebaseConfig);
        }
        const database = firebase.database();

        const CARD_SETS = {
          'short-a': ['apple', 'ant', 'bag', 'crab'],
          'short-e': ['egg', 'bell', 'helmet', 'nest'],
          'short-i': ['insect', 'fin', 'lips', 'win'],
          'short-o': ['octopus', 'dog', 'pot', 'stop'],
          'short-u': ['umbrella', 'cup', 'drum', 'hut'],
          'digraph-ch': ['chest', 'chips', 'lunch', 'watch'],
          'digraph-sh': ['brush', 'dish', 'shell', 'shovel'],
          'digraph-th-voiced': ['brother', 'clothes', 'mother', 'weather'],
          'digraph-th-voiceless': ['bath', 'path', 'thanks', 'think'],
          'digraph-ph': ['phone', 'photo', 'elephant', 'alphabet'],
          'consonant-y': ['canyon', 'yard', 'yogurt', 'yoyo']
        };

        const CARD_IMAGES = {
          'short-a-apple': 'https://i.postimg.cc/wMYpZJcF/short-a-apple.png',
          'short-a-ant': 'https://i.postimg.cc/kGPmz8Fc/short-a-ant.png',
          'short-a-bag': 'https://i.postimg.cc/kGPmz8Fs/short-a-bag.png',
          'short-a-crab': 'https://i.postimg.cc/4yRgqtbB/short-a-crab.png',
          'short-e-egg': 'https://i.postimg.cc/prQHHTsR/short-e-egg.png',
          'short-e-bell': 'https://i.postimg.cc/6qVXX3Mw/short-e-bell.png',
          'short-e-helmet': 'https://i.postimg.cc/gjyWWJgY/short-e-helmet.png',
          'short-e-nest': 'https://i.postimg.cc/mk3ssDmT/short-e-nest.png',
          'short-i-insect': 'https://i.postimg.cc/8kLDWKTS/short-i-insect.png',
          'short-i-fin': 'https://i.postimg.cc/RCw9fsv5/short-i-fin.png',
          'short-i-lips': 'https://i.postimg.cc/8kLDWKTg/short-i-lips.png',
          'short-i-win': 'https://i.postimg.cc/057xmW9q/short-i-win.png',
          'short-o-octopus': 'https://i.postimg.cc/fTZsvcb7/short-o-octopus.png',
          'short-o-dog': 'https://i.postimg.cc/xTYQPvdM/short-o-dog.png',
          'short-o-pot': 'https://i.postimg.cc/GhrRjFpk/short-o-pot.png',
          'short-o-stop': 'https://i.postimg.cc/gkdpKV03/short-o-stop.png',
          'short-u-umbrella': 'https://i.postimg.cc/x11Sw9MQ/short-u-umbrella.png',
          'short-u-cup': 'https://i.postimg.cc/y88zM7cB/short-u-cup.png',
          'short-u-drum': 'https://i.postimg.cc/2SSfsChr/short-u-drum.png',
          'short-u-hut': 'https://i.postimg.cc/T33XzTg6/short-u-hut.png',
          'digraph-ch-chest': 'https://i.postimg.cc/wMZw3C9P/digraph-ch-chest.png',
          'digraph-ch-chips': 'https://i.postimg.cc/C5Xcd3wr/digraph-ch-chips.png',
          'digraph-ch-lunch': 'https://i.postimg.cc/hv62hkK3/digraph-ch-lunch.png',
          'digraph-ch-watch': 'https://i.postimg.cc/NFSdL3Qz/digraph-ch-watch.png',
          'digraph-sh-brush': 'https://i.postimg.cc/Gpfv13fc/digraph-sh-brush.png',
          'digraph-sh-dish': 'https://i.postimg.cc/g073Pc7d/digraph-sh-dish.png',
          'digraph-sh-shell': 'https://i.postimg.cc/rpH5LyHM/digraph-sh-shell.png',
          'digraph-sh-shovel': 'https://i.postimg.cc/VNhXcshz/digraph-sh-shovel.png',
          'digraph-th-voiced-brother': 'https://i.postimg.cc/DZXhx5sz/digraph-th-voiced-brother.png',
          'digraph-th-voiced-clothes': 'https://i.postimg.cc/j57TMvN5/digraph-th-voiced-clothes.png',
          'digraph-th-voiced-mother': 'https://i.postimg.cc/W3kV5Srt/digraph-th-voiced-mother.png',
          'digraph-th-voiced-weather': 'https://i.postimg.cc/MTQw9tRH/digraph-th-voiced-weather.png',
          'digraph-th-voiceless-bath': 'https://i.postimg.cc/GpNrP64g/digraph-th-unvoiced-bath.png',
          'digraph-th-voiceless-path': 'https://i.postimg.cc/9fSVPsDk/digraph-th-unvoiced-path.png',
          'digraph-th-voiceless-thanks': 'https://i.postimg.cc/wBPH5n1b/digraph-th-unvoiced-thanks.png',
          'digraph-th-voiceless-think': 'https://i.postimg.cc/xd7YGBX4/digraph-th-unvoiced-think.png',
          'digraph-ph-phone': 'https://i.postimg.cc/rw811PWx/digraph-ph-phone.png',
          'digraph-ph-photo': 'https://i.postimg.cc/cLsRRbY3/digraph-ph-photo.png',
          'digraph-ph-elephant': 'https://i.postimg.cc/6p9rrmRR/digraph-ph-elephant.png',
          'digraph-ph-alphabet': 'https://i.postimg.cc/P5tWWRZw/digraph-ph-alphabet.png',
          'consonant-y-canyon': 'https://i.postimg.cc/fRXrSRtt/consonant-y-canyon.png',
          'consonant-y-yard': 'https://i.postimg.cc/cLYbtLg3/consonant-y-yard.png',
          'consonant-y-yogurt': 'https://i.postimg.cc/FHcBkHdJ/consonant-y-yogurt.png',
          'consonant-y-yoyo': 'https://i.postimg.cc/4xtSHx7H/consonant-y-yoyo.png'
        };

        const SET_NAMES = {
          'short-a': 'Short a', 'short-e': 'Short e', 'short-i': 'Short i',
          'short-o': 'Short o', 'short-u': 'Short u', 'digraph-ch': 'digraph ch',
          'digraph-sh': 'digraph sh', 'digraph-th-voiced': 'digraph th voiced',
          'digraph-th-voiceless': 'digraph th voiceless', 'digraph-ph': 'digraph ph',
          'consonant-y': 'consonant y'
        };

        const ArrowUp = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="12" y1="19" x2="12" y2="5"/><polyline points="5 12 12 5 19 12"/></svg>;
        const Users = ({size=20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>;
        const Settings = ({size=18}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="3"/><path d="M12 1v6m0 6v6m9-9h-6m-6 0H3"/></svg>;
        const Copy = ({size=16}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>;
        const Check = ({size=16}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="20 6 9 17 4 12"/></svg>;
        const Wifi = ({size=20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M5 12.55a11 11 0 0 1 14.08 0"/><path d="M1.42 9a16 16 0 0 1 21.16 0"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><line x1="12" y1="20" x2="12.01" y2="20"/></svg>;
        const WifiOff = ({size=16}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="1" y1="1" x2="23" y2="23"/><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"/><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"/></svg>;

        const GoFishPhonics = () => {
          const [gameState, setGameState] = useState('setup');
          const [roomCode, setRoomCode] = useState('');
          const [playerName, setPlayerName] = useState('');
          const [opponentName, setOpponentName] = useState('');
          const [settings, setSettings] = useState({
            endTurnMode: 'always-draw',
            selectedSets: Object.keys(CARD_SETS),
            firstPlayer: 'host'
          });
          const [copied, setCopied] = useState(false);
          const [connected, setConnected] = useState(false);
          const [isHost, setIsHost] = useState(false);
          const [deck, setDeck] = useState([]);
          const [myHand, setMyHand] = useState([]);
          const [opponentHandCount, setOpponentHandCount] = useState(0);
          const [mySets, setMySets] = useState([]);
          const [opponentSets, setOpponentSets] = useState([]);
          const [isMyTurn, setIsMyTurn] = useState(false);
          const [selectedCard, setSelectedCard] = useState(null);
          const [draggedCard, setDraggedCard] = useState(null);
          const [dragOverIndex, setDragOverIndex] = useState(null);
          const [myScore, setMyScore] = useState(0);
          const [opponentScore, setOpponentScore] = useState(0);
          const [deckCount, setDeckCount] = useState(0);
          const [gameEnded, setGameEnded] = useState(false);
          const [winner, setWinner] = useState(null);
          const [showAllCards, setShowAllCards] = useState(false);
          const [showSets, setShowSets] = useState(false);
          const [disconnectMessage, setDisconnectMessage] = useState('');
          const [myPlayerId, setMyPlayerId] = useState('');
          
          const roomRef = useRef(null);
          const gameDataRef = useRef(null);
          const presenceRef = useRef(null);

          // Preload all card images
          useEffect(() => {
            Object.values(CARD_IMAGES).forEach(imageUrl => {
              const img = new Image();
              img.src = imageUrl;
            });
          }, []);

          // Initialize room on mount
          useEffect(() => {
            const urlParams = new URLSearchParams(window.location.search);
            const joinCode = urlParams.get('join');
            
            const playerId = 'player_' + Math.random().toString(36).substr(2, 9);
            setMyPlayerId(playerId);
            
            if (joinCode) {
              setRoomCode(joinCode);
              setIsHost(false);
              checkRoomExists(joinCode);
            } else {
              const newRoomCode = generateRoomCode();
              setRoomCode(newRoomCode);
              setIsHost(true);
              createRoom(newRoomCode);
            }
          }, []);

          const generateRoomCode = () => {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
          };

          const createRoom = (code) => {
            roomRef.current = database.ref(`rooms/${code}`);
            roomRef.current.set({
              host: '',
              guest: '',
              hostConnected: false,
              guestConnected: false,
              hostName: '',
              guestName: '',
              createdAt: Date.now()
            });
          };

          const checkRoomExists = async (code) => {
            const snapshot = await database.ref(`rooms/${code}`).once('value');
            if (!snapshot.exists()) {
              alert('Room does not exist. Please check the link.');
              window.location.href = window.location.origin + window.location.pathname;
            } else {
              roomRef.current = database.ref(`rooms/${code}`);
            }
          };

          const connectToRoom = () => {
            if (!playerName.trim()) {
              alert('Please enter your name');
              return;
            }

            if (isHost) {
              roomRef.current.update({
                host: myPlayerId,
                hostConnected: true,
                hostName: playerName
              });
              
              roomRef.current.child('guest').on('value', (snapshot) => {
                const guestId = snapshot.val();
                if (guestId) {
                  setConnected(true);
                }
              });
              
              roomRef.current.child('guestName').on('value', (snapshot) => {
                const name = snapshot.val();
                if (name) {
                  setOpponentName(name);
                }
              });
              
              roomRef.current.child('guestConnected').on('value', (snapshot) => {
                const isConnected = snapshot.val();
                if (isConnected === false && connected) {
                  setDisconnectMessage(`${opponentName || 'Your opponent'} has disconnected. The game has ended.`);
                  setGameEnded(true);
                }
              });
            } else {
              roomRef.current.update({
                guest: myPlayerId,
                guestConnected: true,
                guestName: playerName
              });
              
              roomRef.current.child('host').on('value', (snapshot) => {
                const hostId = snapshot.val();
                if (hostId) {
                  setConnected(true);
                }
              });
              
              roomRef.current.child('hostName').on('value', (snapshot) => {
                const name = snapshot.val();
                if (name) {
                  setOpponentName(name);
                }
              });
              
              roomRef.current.child('hostConnected').on('value', (snapshot) => {
                const isConnected = snapshot.val();
                if (isConnected === false && connected) {
                  setDisconnectMessage(`${opponentName || 'The host'} has disconnected. The game has ended.`);
                  setGameEnded(true);
                }
              });
            }

            presenceRef.current = database.ref('.info/connected');
            presenceRef.current.on('value', (snapshot) => {
              if (snapshot.val()) {
                const playerField = isHost ? 'hostConnected' : 'guestConnected';
                const playerPresence = roomRef.current.child(playerField);
                playerPresence.onDisconnect().set(false);
                playerPresence.set(true);
              }
            });

            gameDataRef.current = database.ref(`games/${roomCode}`);
            gameDataRef.current.on('value', handleGameDataChange);
          };

          // Auto-connect when room is ready and player has entered name
          useEffect(() => {
            if (roomRef.current && playerName.trim() && !connected && myPlayerId) {
              connectToRoom();
            }
          }, [playerName, roomRef.current, myPlayerId]);

          const handleGameDataChange = (snapshot) => {
            const data = snapshot.val();
            if (!data) return;

            const myRole = isHost ? 'host' : 'guest';
            const opponentRole = isHost ? 'guest' : 'host';

            if (data.gameState === 'playing' && gameState === 'setup') {
              setSettings(data.settings);
              setMyHand(data[`${myRole}Hand`] || []);
              setOpponentHandCount(data[`${opponentRole}HandCount`] || 0);
              setDeckCount(data.deckCount || 0);
              setIsMyTurn(data.currentTurn === myRole);
              setGameState('playing');
            }

            if (data.gameState === 'playing') {
              setMyHand(data[`${myRole}Hand`] || myHand);
              setOpponentHandCount(data[`${opponentRole}HandCount`] || 0);
              setDeckCount(data.deckCount || 0);
              setIsMyTurn(data.currentTurn === myRole);
              setMySets(data[`${myRole}Sets`] || []);
              setOpponentSets(data[`${opponentRole}Sets`] || []);
              setMyScore(data[`${myRole}Score`] || 0);
              setOpponentScore(data[`${opponentRole}Score`] || 0);

              if (data.deck && isHost) {
                setDeck(data.deck);
              }
            }

            if (data.gameState === 'ended' && !gameEnded) {
              const myFinalScore = data[`${myRole}Score`] || 0;
              const opponentFinalScore = data[`${opponentRole}Score`] || 0;
              
              setMyScore(myFinalScore);
              setOpponentScore(opponentFinalScore);
              
              if (myFinalScore > opponentFinalScore) {
                setWinner('you');
              } else if (opponentFinalScore > myFinalScore) {
                setWinner('opponent');
              } else {
                setWinner('tie');
              }
              
              setGameEnded(true);
            }

            if (data.gameState === 'setup' && gameState === 'playing') {
              resetGame();
            }
          };

          const shuffleArray = (arr) => {
            const a = [...arr];
            for (let i = a.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [a[i], a[j]] = [a[j], a[i]];
            }
            return a;
          };

          const initializeDeck = () => {
            const cards = [];
            settings.selectedSets.forEach(sk => 
              CARD_SETS[sk].forEach(c => 
                cards.push({ id: `${sk}-${c}`, set: sk, name: c })
              )
            );
            return shuffleArray(cards);
          };

          const startGame = () => {
            if (!playerName.trim()) {
              alert('Please enter your name');
              return;
            }
            if (!connected) {
              alert('Waiting for opponent');
              return;
            }

            const newDeck = initializeDeck();
            const hostHand = newDeck.slice(0, 4);
            const guestHand = newDeck.slice(4, 8);
            const remaining = newDeck.slice(8);
            const hostGoesFirst = settings.firstPlayer === 'host';

            gameDataRef.current.set({
              gameState: 'playing',
              settings: settings,
              deck: remaining,
              deckCount: remaining.length,
              hostHand: hostHand,
              guestHand: guestHand,
              hostHandCount: 4,
              guestHandCount: 4,
              hostSets: [],
              guestSets: [],
              hostScore: 0,
              guestScore: 0,
              currentTurn: hostGoesFirst ? 'host' : 'guest'
            });

            setDeck(remaining);
            setMyHand(hostHand);
            setOpponentHandCount(4);
            setDeckCount(remaining.length);
            setIsMyTurn(hostGoesFirst);
            setGameState('playing');
          };

          const drawCard = async () => {
            if (deckCount === 0) {
              if (settings.endTurnMode === 'always-draw') endTurn();
              return;
            }

            const snapshot = await gameDataRef.current.once('value');
            const data = snapshot.val();
            const currentDeck = data.deck || [];
            
            if (currentDeck.length === 0) {
              if (settings.endTurnMode === 'always-draw') endTurn();
              return;
            }

            const newDeck = [...currentDeck];
            const drawnCard = newDeck.pop();
            const myRole = isHost ? 'host' : 'guest';
            const newHand = [...myHand, drawnCard];

            await gameDataRef.current.update({
              deck: newDeck,
              deckCount: newDeck.length,
              [`${myRole}Hand`]: newHand,
              [`${myRole}HandCount`]: newHand.length
            });

            setMyHand(newHand);
            setDeck(newDeck);
            setDeckCount(newDeck.length);

            if (settings.endTurnMode === 'always-draw') {
              endTurn();
            }
          };

          const replenishHand = async (hand) => {
            if (deckCount === 0 || hand.length >= 4) return hand;

            const snapshot = await gameDataRef.current.once('value');
            const data = snapshot.val();
            const currentDeck = data.deck || [];
            
            const newDeck = [...currentDeck];
            const newHand = [...hand];
            
            while (newHand.length < 4 && newDeck.length > 0) {
              newHand.push(newDeck.pop());
            }

            const myRole = isHost ? 'host' : 'guest';
            await gameDataRef.current.update({
              deck: newDeck,
              deckCount: newDeck.length,
              [`${myRole}Hand`]: newHand,
              [`${myRole}HandCount`]: newHand.length
            });

            return newHand;
          };

          const giveCard = async () => {
            if (!selectedCard) return;

            const snapshot = await gameDataRef.current.once('value');
            const data = snapshot.val();
            
            const myRole = isHost ? 'host' : 'guest';
            const opponentRole = isHost ? 'guest' : 'host';
            
            const newMyHand = myHand.filter(c => c.id !== selectedCard.id);
            const opponentHand = data[`${opponentRole}Hand`] || [];
            const newOpponentHand = [...opponentHand, selectedCard];

            const replenishedHand = await replenishHand(newMyHand);

            await gameDataRef.current.update({
              [`${myRole}Hand`]: replenishedHand,
              [`${myRole}HandCount`]: replenishedHand.length,
              [`${opponentRole}Hand`]: newOpponentHand,
              [`${opponentRole}HandCount`]: newOpponentHand.length
            });

            setMyHand(replenishedHand);
            setSelectedCard(null);
          };

          const endTurn = async () => {
            const opponentRole = isHost ? 'guest' : 'host';
            await gameDataRef.current.update({
              currentTurn: opponentRole
            });
            setIsMyTurn(false);
            setSelectedCard(null);
          };

          const checkForSets = async (hand) => {
            for (let i = 0; i <= hand.length - 4; i++) {
              const fourCards = hand.slice(i, i + 4);
              const firstSet = fourCards[0].set;
              
              if (fourCards.every(card => card.set === firstSet)) {
                await completeSet(firstSet, hand);
                return true;
              }
            }
            return false;
          };

          const completeSet = async (setKey, hand) => {
            const setCards = hand.filter(c => c.set === setKey);
            const remainingCards = hand.filter(c => c.set !== setKey);
            
            const replenishedHand = await replenishHand(remainingCards);
            
            const myRole = isHost ? 'host' : 'guest';
            const snapshot = await gameDataRef.current.once('value');
            const data = snapshot.val();
            
            const currentSets = data[`${myRole}Sets`] || [];
            const newSets = [...currentSets, { set: setKey, cards: setCards }];
            const newScore = newSets.length;

            await gameDataRef.current.update({
              [`${myRole}Hand`]: replenishedHand,
              [`${myRole}HandCount`]: replenishedHand.length,
              [`${myRole}Sets`]: newSets,
              [`${myRole}Score`]: newScore
            });

            setMyHand(replenishedHand);
            setMySets(newSets);
            setMyScore(newScore);
          };

          useEffect(() => {
            if (myHand.length > 0 && gameState === 'playing') {
              checkForSets(myHand);
            }
          }, [myHand]);

          useEffect(() => {
            if (gameState === 'playing' && deckCount === 0 && myHand.length === 0 && opponentHandCount === 0 && !gameEnded) {
              gameDataRef.current.update({
                gameState: 'ended'
              });
            }
          }, [deckCount, myHand.length, opponentHandCount, gameState, gameEnded]);

          const handleDragStart = (e, card, index) => {
            setDraggedCard({ card, index });
          };

          const handleDragOver = (e, index) => {
            e.preventDefault();
            setDragOverIndex(index);
          };

          const handleDrop = async (e, dropIndex) => {
            e.preventDefault();
            if (draggedCard === null) return;

            const newHand = [...myHand];
            const [removed] = newHand.splice(draggedCard.index, 1);
            newHand.splice(dropIndex, 0, removed);
            
            setMyHand(newHand);
            setDraggedCard(null);
            setDragOverIndex(null);

            const myRole = isHost ? 'host' : 'guest';
            await gameDataRef.current.update({
              [`${myRole}Hand`]: newHand
            });
          };

          const copyInviteLink = () => {
            navigator.clipboard.writeText(`${window.location.origin}${window.location.pathname}?join=${roomCode}`);
            setCopied(true);
            setTimeout(() => setCopied(false), 2000);
          };

          const resetGame = () => {
            setGameState('setup');
            setGameEnded(false);
            setWinner(null);
            setMyHand([]);
            setOpponentHandCount(0);
            setMySets([]);
            setOpponentSets([]);
            setMyScore(0);
            setOpponentScore(0);
            setDeck([]);
            setDeckCount(0);
          };

          const returnToSetup = async () => {
            await gameDataRef.current.update({
              gameState: 'setup'
            });
            resetGame();
          };

          // Cleanup on unmount
          useEffect(() => {
            return () => {
              if (roomRef.current) {
                const playerField = isHost ? 'hostConnected' : 'guestConnected';
                roomRef.current.update({ [playerField]: false });
              }
              if (gameDataRef.current) {
                gameDataRef.current.off();
              }
              if (presenceRef.current) {
                presenceRef.current.off();
              }
            };
          }, []);

          if (gameState === 'setup') {
            return (
              <div className="w-full min-h-screen p-8 flex items-center justify-center" style={{background: 'linear-gradient(to bottom, #dafbe9, #c4f7e5)'}}>
                <div className="bg-white rounded-lg p-12 max-w-5xl w-full" style={{margin: '3cm', borderTop: '4px solid #23879f'}}>
                  <div className="text-center mb-8">
                    <img src="https://i.postimg.cc/GpmYBwxD/Adaptivelogotrans.png" alt="Adaptive Logo" className="mx-auto mb-4" style={{width: '200px'}} />
                    <h1 className="text-4xl font-bold" style={{color: '#004870'}}>Go-Fish Phonics</h1>
                  </div>
                  <div className="space-y-6">
                    <div className="grid grid-cols-2 gap-6">
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">Your Name</label>
                        <input 
                          type="text" 
                          value={playerName} 
                          onChange={(e) => setPlayerName(e.target.value)} 
                          className="w-full px-4 py-2 border border-gray-300 rounded-lg" 
                          placeholder="Enter your name" 
                        />
                      </div>
                      {isHost && (
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-2">Turn End Mode</label>
                          <select 
                            value={settings.endTurnMode} 
                            onChange={(e) => setSettings({...settings, endTurnMode: e.target.value})} 
                            className="w-full px-4 py-2 border border-gray-300 rounded-lg"
                          >
                            <option value="always-draw">Classic Mode</option>
                            <option value="manual-end">Strategic Mode</option>
                          </select>
                        </div>
                      )}
                    </div>
                    {isHost && (
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">Who Goes First?</label>
                        <select 
                          value={settings.firstPlayer} 
                          onChange={(e) => setSettings({...settings, firstPlayer: e.target.value})} 
                          className="w-full px-4 py-2 border border-gray-300 rounded-lg"
                        >
                          <option value="host">Host (You)</option>
                          <option value="opponent">Opponent</option>
                        </select>
                      </div>
                    )}
                    {isHost && (
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">
                          <Settings size={18} /> Select Card Sets
                        </label>
                        <div className="bg-gray-50 p-4 rounded-lg">
                          <div className="grid grid-cols-4 gap-3 text-sm">
                            {Object.entries(SET_NAMES).map(([key, name]) => (
                              <div key={key} className="flex items-center">
                                <input 
                                  type="checkbox" 
                                  checked={settings.selectedSets.includes(key)} 
                                  onChange={(e) => {
                                    if (e.target.checked) {
                                      setSettings({...settings, selectedSets: [...settings.selectedSets, key]});
                                    } else {
                                      setSettings({...settings, selectedSets: settings.selectedSets.filter(s => s !== key)});
                                    }
                                  }} 
                                  className="mr-2" 
                                />
                                {name}
                              </div>
                            ))}
                          </div>
                        </div>
                      </div>
                    )}
                    {isHost && (
                      <div className="bg-blue-50 border-2 border-blue-300 rounded-lg p-4">
                        <div className="flex items-center justify-between mb-2">
                          <div className="flex items-center gap-2">
                            <Users size={20} />
                            <span className="font-semibold text-blue-900">Invite Opponent</span>
                          </div>
                          <div className="flex items-center gap-3">
                            <div className="px-3 py-1 bg-white border border-gray-300 rounded text-sm">
                              {connected && opponentName ? opponentName : 'No connection'}
                            </div>
                            {connected ? (
                              <span className="text-green-600 text-sm flex items-center gap-1">
                                <Wifi size={16} /> Connected
                              </span>
                            ) : (
                              <span className="text-orange-600 text-sm flex items-center gap-1">
                                <WifiOff size={16} /> Waiting...
                              </span>
                            )}
                          </div>
                        </div>
                        <p className="text-sm text-gray-700 mb-3">Share this link:</p>
                        <div className="flex gap-2">
                          <input 
                            type="text" 
                            value={`${window.location.origin}${window.location.pathname}?join=${roomCode}`} 
                            readOnly 
                            className="flex-1 px-3 py-2 bg-white border border-gray-300 rounded text-sm" 
                          />
                          <button 
                            onClick={copyInviteLink}
                            className="px-4 py-2 text-white rounded hover:opacity-90 flex items-center gap-2" 
                            style={{backgroundColor: '#50d3df'}}
                          >
                            {copied ? <Check size={16} /> : <Copy size={16} />}
                            {copied ? 'Copied!' : 'Copy'}
                          </button>
                        </div>
                      </div>
                    )}
                    {!isHost && (
                      <div className="bg-green-50 border-2 border-green-300 rounded-lg p-4">
                        <p className="text-green-900 font-semibold mb-2">Joining game...</p>
                        <p className="text-sm text-gray-700 mb-2">Enter your name above to connect</p>
                        {connected && (
                          <p className="text-green-600 text-sm mt-2 flex items-center gap-1">
                            <Wifi size={16} /> Connected! Waiting for host to start game...
                          </p>
                        )}
                      </div>
                    )}
                    {isHost ? (
                      <button 
                        onClick={startGame} 
                        disabled={!connected}
                        className={`w-full py-3 rounded-lg font-semibold ${connected ? 'text-white hover:opacity-90' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`} 
                        style={connected ? {backgroundColor: '#23879f'} : {}}
                      >
                        {connected ? 'Start Game' : 'Waiting for Opponent...'}
                      </button>
                    ) : (
                      <div className="w-full py-3 text-center text-gray-600 font-semibold">
                        {connected ? 'Connected - Waiting for host to start game...' : 'Enter your name to connect'}
                      </div>
                    )}
                  </div>
                </div>
              </div>
            );
          }

          return (
            <div className="w-full h-screen bg-white flex flex-col">
              {gameEnded && disconnectMessage && (
                <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                  <div className="bg-white rounded-lg shadow-2xl p-8 max-w-md text-center">
                    <h2 className="text-2xl font-bold text-red-600 mb-4">Game Ended</h2>
                    <p className="text-gray-700 mb-6">{disconnectMessage}</p>
                  </div>
                </div>
              )}
              {showAllCards && (
                <div className="absolute inset-0 z-50 flex items-center justify-end">
                  <div className="absolute inset-0 bg-black bg-opacity-50" onClick={() => setShowAllCards(false)}></div>
                  <div className="bg-white rounded-lg shadow-2xl p-6 max-h-[90vh] overflow-y-auto relative" style={{width: '66.66%', marginLeft: '38px'}} onClick={(e) => e.stopPropagation()} onDragOver={(e) => {
                    e.preventDefault();
                    const container = e.currentTarget;
                    const rect = container.getBoundingClientRect();
                    const scrollThreshold = 100;
                    const scrollSpeed = 10;
                    
                    if (e.clientY < rect.top + scrollThreshold) {
                      container.scrollTop -= scrollSpeed;
                    } else if (e.clientY > rect.bottom - scrollThreshold) {
                      container.scrollTop += scrollSpeed;
                    }
                  }}>
                    <div className="flex justify-between items-center mb-4">
                      <h2 className="text-2xl font-bold">Your Hand - Organize Your Cards</h2>
                      <button 
                        onClick={() => setShowAllCards(false)}
                        className="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600"
                      >
                        Close
                      </button>
                    </div>
                    <div className="grid grid-cols-4 gap-4">
                      {myHand.map((card, i) => (
                        <div 
                          key={card.id} 
                          draggable 
                          onDragStart={(e) => handleDragStart(e, card, i)} 
                          onDragOver={(e) => handleDragOver(e, i)} 
                          onDrop={(e) => handleDrop(e, i)} 
                          onClick={() => setSelectedCard(selectedCard?.id === card.id ? null : card)}
                          className={`w-44 h-60 rounded-lg shadow-lg cursor-pointer relative ${selectedCard?.id === card.id ? 'border-4 border-yellow-400' : 'border-0'} ${dragOverIndex === i ? 'ring-4 ring-blue-400' : ''}`}
                        >
                          <img src={CARD_IMAGES[card.id]} alt={card.name} className="w-full h-full object-cover rounded-lg" />
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              )}
              {showSets && (
                <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onClick={() => setShowSets(false)}>
                  <div className="bg-white rounded-lg shadow-2xl p-6 max-h-[90vh] overflow-y-auto" style={{width: '95vw'}} onClick={(e) => e.stopPropagation()}>
                    <div className="flex justify-between items-center mb-6">
                      <h2 className="text-2xl font-bold">Completed Sets</h2>
                      <button 
                        onClick={() => setShowSets(false)}
                        className="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600"
                      >
                        Close
                      </button>
                    </div>
                    <div className="mb-8">
                      <h3 className="text-xl font-semibold mb-4 text-blue-600">{playerName}'s Sets ({myScore})</h3>
                      {mySets.length === 0 ? (
                        <p className="text-gray-500 italic">No sets completed yet</p>
                      ) : (
                        <div className="grid grid-cols-2 gap-8">
                          {mySets.map((set, i) => (
                            <div key={i} className="bg-blue-50 p-6 rounded-lg border-2 border-blue-300">
                              <div className="relative flex justify-center items-center" style={{height: '200px'}}>
                                {set.cards.map((card, j) => (
                                  <img 
                                    key={j} 
                                    src={CARD_IMAGES[card.id]} 
                                    alt={card.name}
                                    className="absolute rounded-lg border-3 border-blue-600 object-cover shadow-xl transition-transform hover:scale-105 hover:z-10"
                                    style={{
                                      width: '117px',
                                      height: '160px',
                                      left: `${20 + j * 20}%`,
                                      transform: `translateX(-50%) rotate(${(j - 1.5) * 5}deg)`,
                                      zIndex: j
                                    }}
                                  />
                                ))}
                              </div>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                    <div>
                      <h3 className="text-xl font-semibold mb-4 text-red-600">{opponentName}'s Sets ({opponentScore})</h3>
                      {opponentSets.length === 0 ? (
                        <p className="text-gray-500 italic">No sets completed yet</p>
                      ) : (
                        <div className="grid grid-cols-2 gap-8">
                          {opponentSets.map((set, i) => (
                            <div key={i} className="bg-red-50 p-6 rounded-lg border-2 border-red-300">
                              <div className="relative flex justify-center items-center" style={{height: '200px'}}>
                                {set.cards.map((card, j) => (
                                  <img 
                                    key={j} 
                                    src={CARD_IMAGES[card.id]} 
                                    alt={card.name}
                                    className="absolute rounded-lg border-3 border-blue-600 object-cover shadow-xl transition-transform hover:scale-105 hover:z-10"
                                    style={{
                                      width: '117px',
                                      height: '160px',
                                      left: `${20 + j * 20}%`,
                                      transform: `translateX(-50%) rotate(${(j - 1.5) * 5}deg)`,
                                      zIndex: j
                                    }}
                                  />
                                ))}
                              </div>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              )}
              {gameEnded && !disconnectMessage && winner && (
                <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 overflow-y-auto py-8">
                  <div className="bg-white rounded-lg shadow-2xl p-8 text-center my-auto" style={{width: '95vw'}}>
                    <h2 className="text-3xl font-bold mb-4">
                      {winner === 'you' ? 'üéâ You Win! üéâ' : winner === 'opponent' ? 'üòî You Lose' : 'ü§ù It\'s a Tie!'}
                    </h2>
                    <div className="text-xl mb-6">
                      <p className="mb-2">Final Score:</p>
                      <p className="font-bold">{playerName}: {myScore}</p>
                      <p className="font-bold">{opponentName}: {opponentScore}</p>
                    </div>
                    <div className="mb-6">
                      <div className="mb-6">
                        <h3 className="text-lg font-semibold mb-3 text-blue-600">{playerName}'s Sets</h3>
                        {mySets.length === 0 ? (
                          <p className="text-gray-500 italic text-sm">No sets completed</p>
                        ) : (
                          <div className="grid grid-cols-2 gap-8">
                            {mySets.map((set, i) => (
                              <div key={i} className="bg-blue-50 p-6 rounded-lg border-2 border-blue-300">
                                <div className="relative flex justify-center items-center" style={{height: '200px'}}>
                                  {set.cards.map((card, j) => (
                                    <img 
                                      key={j} 
                                      src={CARD_IMAGES[card.id]} 
                                      alt={card.name}
                                      className="absolute rounded-lg border-3 border-blue-600 object-cover shadow-xl transition-transform hover:scale-105 hover:z-10"
                                      style={{
                                        width: '117px',
                                        height: '160px',
                                        left: `${20 + j * 20}%`,
                                        transform: `translateX(-50%) rotate(${(j - 1.5) * 5}deg)`,
                                        zIndex: j
                                      }}
                                    />
                                  ))}
                                </div>
                              </div>
                            ))}
                          </div>
                        )}
                      </div>
                      <div>
                        <h3 className="text-lg font-semibold mb-3 text-red-600">{opponentName}'s Sets</h3>
                        {opponentSets.length === 0 ? (
                          <p className="text-gray-500 italic text-sm">No sets completed</p>
                        ) : (
                          <div className="grid grid-cols-2 gap-8">
                            {opponentSets.map((set, i) => (
                              <div key={i} className="bg-red-50 p-6 rounded-lg border-2 border-red-300">
                                <div className="relative flex justify-center items-center" style={{height: '200px'}}>
                                  {set.cards.map((card, j) => (
                                    <img 
                                      key={j} 
                                      src={CARD_IMAGES[card.id]} 
                                      alt={card.name}
                                      className="absolute rounded-lg border-3 border-blue-600 object-cover shadow-xl transition-transform hover:scale-105 hover:z-10"
                                      style={{
                                        width: '117px',
                                        height: '160px',
                                        left: `${20 + j * 20}%`,
                                        transform: `translateX(-50%) rotate(${(j - 1.5) * 5}deg)`,
                                        zIndex: j
                                      }}
                                    />
                                  ))}
                                </div>
                              </div>
                            ))}
                          </div>
                        )}
                      </div>
                    </div>
                    <p className="text-gray-600 text-sm mb-4">
                      {isHost ? 'Return to setup to start a new game or change settings.' : 'Waiting for host to start a new game...'}
                    </p>
                    <button 
                      onClick={returnToSetup} 
                      className="px-6 py-3 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700"
                    >
                      Return to Setup
                    </button>
                  </div>
                </div>
              )}
              <div className="absolute top-4 left-4 z-20">
                <img src="https://i.postimg.cc/GpmYBwxD/Adaptivelogotrans.png" alt="Adaptive Logo" className="mb-2" style={{width: '120px'}} />
                <div className={`bg-white shadow-lg rounded-lg p-3 ${isMyTurn ? 'animate-pulse border-2 border-yellow-400' : 'border-2 border-gray-300'}`}>
                  <div className="text-sm font-semibold text-gray-600 mb-1">{playerName || 'Your'}'s Hand</div>
                  <div className="text-lg font-bold">{isMyTurn ? "Your Turn" : `${opponentName || "Opponent"}'s Turn`}</div>
                </div>
              </div>
              <div className="absolute top-4 right-4 bg-white shadow-lg rounded-lg p-3 z-20 border-2 border-gray-300">
                <div className="flex gap-6">
                  <div className="text-center">
                    <div className="text-xs text-gray-600 mb-1">{playerName}</div>
                    <div className="text-2xl font-bold text-blue-600">{myScore}</div>
                  </div>
                  <div className="text-center">
                    <div className="text-xs text-gray-600 mb-1">{opponentName}</div>
                    <div className="text-2xl font-bold text-red-600">{opponentScore}</div>
                  </div>
                </div>
              </div>
              <div className="flex-1 p-4 flex items-start justify-center">
                <div className="flex gap-2">
                  {Array(4).fill(0).map((_, i) => (
                    <div key={i} className="w-20 h-28 bg-blue-500 rounded-lg shadow-lg border-4 border-blue-700" />
                  ))}
                </div>
              </div>
              <div className="flex justify-center items-center py-4">
                <div className="text-center">
                  <button 
                    onClick={drawCard} 
                    disabled={!isMyTurn || deckCount === 0}
                    className={`w-24 h-32 rounded-lg shadow-xl border-4 font-bold text-white text-xl ${!isMyTurn || deckCount === 0 ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}`} 
                    style={deckCount > 0 ? {backgroundColor: '#23879f', borderColor: '#004870'} : {backgroundColor: '#b0b0b0', borderColor: '#808080'}}
                  >
                    {isHost ? deckCount : ''}
                  </button>
                  <div className="text-sm mt-2 font-semibold">Deck</div>
                </div>
                {settings.endTurnMode === 'manual-end' && (
                  <button 
                    onClick={endTurn} 
                    disabled={!isMyTurn} 
                    className={`ml-8 px-6 py-3 rounded-lg font-semibold ${isMyTurn ? 'text-white hover:opacity-90' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`} 
                    style={isMyTurn ? {backgroundColor: '#50d3df'} : {}}
                  >
                    End Turn
                  </button>
                )}
              </div>
              <div className="flex-1 p-4 flex items-end justify-center relative">
                {selectedCard && (
                  <div className="absolute left-8" style={{bottom: 'calc(4rem + 56px)', zIndex: showAllCards ? 60 : 10}}>
                    <div className="relative">
                      <img 
                        src={CARD_IMAGES[selectedCard.id]} 
                        alt={selectedCard.name} 
                        className="rounded-lg shadow-2xl border-4 border-yellow-400"
                        style={{width: '335px', height: '430px'}}
                      />
                      <button 
                        onClick={(e) => { e.stopPropagation(); giveCard(); }} 
                        className="absolute -top-10 left-1/2 transform -translate-x-1/2 bg-red-500 text-white rounded-full p-3 hover:bg-red-600 shadow-lg"
                      >
                        <ArrowUp />
                      </button>
                    </div>
                  </div>
                )}
                <div className="flex flex-col items-center gap-2 max-w-4xl">
                  <div className="flex gap-2">
                    <button 
                      onClick={() => setShowAllCards(!showAllCards)}
                      className="px-4 py-2 bg-blue-500 text-white rounded-lg text-sm font-semibold hover:bg-blue-600 shadow"
                    >
                      {showAllCards ? 'Close Hand View' : 'View All Cards'}
                    </button>
                    <button 
                      onClick={() => setShowSets(!showSets)}
                      className="px-4 py-2 bg-green-500 text-white rounded-lg text-sm font-semibold hover:bg-green-600 shadow"
                    >
                      View Sets ({myScore + opponentScore})
                    </button>
                  </div>
                  <div className="overflow-x-auto flex gap-2 px-4 max-w-full" style={{maxWidth: '800px'}}>
                    {myHand.map((card, i) => (
                      <div 
                        key={card.id} 
                        draggable 
                        onDragStart={(e) => handleDragStart(e, card, i)} 
                        onDragOver={(e) => handleDragOver(e, i)} 
                        onDrop={(e) => handleDrop(e, i)} 
                        onClick={() => setSelectedCard(selectedCard?.id === card.id ? null : card)}
                        className={`w-44 h-60 rounded-lg shadow-lg cursor-pointer relative flex-shrink-0 ${selectedCard?.id === card.id ? 'border-4 border-yellow-400' : 'border-0'} ${dragOverIndex === i ? 'ring-4 ring-blue-400' : ''}`}
                      >
                        <img src={CARD_IMAGES[card.id]} alt={card.name} className="w-full h-full object-cover rounded-lg" />
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            </div>
          );
        };

        ReactDOM.render(<GoFishPhonics />, document.getElementById('root'));
    </script>
</body>
</html>
