<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Go-Fish Phonics</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.4/peerjs.min.js"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const CARD_SETS = {
          'short-a': ['apple', 'ant', 'bag', 'crab'],
          'short-e': ['egg', 'bell', 'helmet', 'nest'],
          'short-i': ['insect', 'fin', 'lips', 'win'],
          'short-o': ['octopus', 'dog', 'pot', 'stop'],
          'short-u': ['umbrella', 'cup', 'drum', 'hut'],
          'digraph-ch': ['chest', 'chips', 'lunch', 'watch'],
          'digraph-sh': ['brush', 'dish', 'shell', 'shovel'],
          'digraph-th-voiced': ['brother', 'clothes', 'mother', 'weather'],
          'digraph-th-voiceless': ['bath', 'path', 'thanks', 'think'],
          'digraph-ph': ['phone', 'photo', 'elephant', 'alphabet'],
          'consonant-y': ['canyon', 'yard', 'yogurt', 'yoyo']
        };

        const CARD_IMAGES = {
          'short-a-apple': 'https://i.postimg.cc/wMYpZJcF/short-a-apple.png',
          'short-a-ant': 'https://i.postimg.cc/kGPmz8Fc/short-a-ant.png',
          'short-a-bag': 'https://i.postimg.cc/kGPmz8Fs/short-a-bag.png',
          'short-a-crab': 'https://i.postimg.cc/4yRgqtbB/short-a-crab.png',
          'short-e-egg': 'https://i.postimg.cc/prQHHTsR/short-e-egg.png',
          'short-e-bell': 'https://i.postimg.cc/6qVXX3Mw/short-e-bell.png',
          'short-e-helmet': 'https://i.postimg.cc/gjyWWJgY/short-e-helmet.png',
          'short-e-nest': 'https://i.postimg.cc/mk3ssDmT/short-e-nest.png',
          'short-i-insect': 'https://i.postimg.cc/8kLDWKTS/short-i-insect.png',
          'short-i-fin': 'https://i.postimg.cc/RCw9fsv5/short-i-fin.png',
          'short-i-lips': 'https://i.postimg.cc/8kLDWKTg/short-i-lips.png',
          'short-i-win': 'https://i.postimg.cc/057xmW9q/short-i-win.png',
          'short-o-octopus': 'https://i.postimg.cc/fTZsvcb7/short-o-octopus.png',
          'short-o-dog': 'https://i.postimg.cc/xTYQPvdM/short-o-dog.png',
          'short-o-pot': 'https://i.postimg.cc/GhrRjFpk/short-o-pot.png',
          'short-o-stop': 'https://i.postimg.cc/gkdpKV03/short-o-stop.png',
          'short-u-umbrella': 'https://i.postimg.cc/x11Sw9MQ/short-u-umbrella.png',
          'short-u-cup': 'https://i.postimg.cc/y88zM7cB/short-u-cup.png',
          'short-u-drum': 'https://i.postimg.cc/2SSfsChr/short-u-drum.png',
          'short-u-hut': 'https://i.postimg.cc/T33XzTg6/short-u-hut.png',
          'digraph-ch-chest': 'https://i.postimg.cc/wMZw3C9P/digraph-ch-chest.png',
          'digraph-ch-chips': 'https://i.postimg.cc/C5Xcd3wr/digraph-ch-chips.png',
          'digraph-ch-lunch': 'https://i.postimg.cc/hv62hkK3/digraph-ch-lunch.png',
          'digraph-ch-watch': 'https://i.postimg.cc/NFSdL3Qz/digraph-ch-watch.png',
          'digraph-sh-brush': 'https://i.postimg.cc/Gpfv13fc/digraph-sh-brush.png',
          'digraph-sh-dish': 'https://i.postimg.cc/g073Pc7d/digraph-sh-dish.png',
          'digraph-sh-shell': 'https://i.postimg.cc/rpH5LyHM/digraph-sh-shell.png',
          'digraph-sh-shovel': 'https://i.postimg.cc/VNhXcshz/digraph-sh-shovel.png',
          'digraph-th-voiced-brother': 'https://i.postimg.cc/DZXhx5sz/digraph-th-voiced-brother.png',
          'digraph-th-voiced-clothes': 'https://i.postimg.cc/j57TMvN5/digraph-th-voiced-clothes.png',
          'digraph-th-voiced-mother': 'https://i.postimg.cc/W3kV5Srt/digraph-th-voiced-mother.png',
          'digraph-th-voiced-weather': 'https://i.postimg.cc/MTQw9tRH/digraph-th-voiced-weather.png',
          'digraph-th-voiceless-bath': 'https://i.postimg.cc/GpNrP64g/digraph-th-unvoiced-bath.png',
          'digraph-th-voiceless-path': 'https://i.postimg.cc/9fSVPsDk/digraph-th-unvoiced-path.png',
          'digraph-th-voiceless-thanks': 'https://i.postimg.cc/wBPH5n1b/digraph-th-unvoiced-thanks.png',
          'digraph-th-voiceless-think': 'https://i.postimg.cc/xd7YGBX4/digraph-th-unvoiced-think.png',
          'digraph-ph-phone': 'https://i.postimg.cc/rw811PWx/digraph-ph-phone.png',
          'digraph-ph-photo': 'https://i.postimg.cc/cLsRRbY3/digraph-ph-photo.png',
          'digraph-ph-elephant': 'https://i.postimg.cc/6p9rrmRR/digraph-ph-elephant.png',
          'digraph-ph-alphabet': 'https://i.postimg.cc/P5tWWRZw/digraph-ph-alphabet.png',
          'consonant-y-canyon': 'https://i.postimg.cc/fRXrSRtt/consonant-y-canyon.png',
          'consonant-y-yard': 'https://i.postimg.cc/cLYbtLg3/consonant-y-yard.png',
          'consonant-y-yogurt': 'https://i.postimg.cc/FHcBkHdJ/consonant-y-yogurt.png',
          'consonant-y-yoyo': 'https://i.postimg.cc/4xtSHx7H/consonant-y-yoyo.png'
        };

        const SET_NAMES = {
          'short-a': 'Short a', 'short-e': 'Short e', 'short-i': 'Short i',
          'short-o': 'Short o', 'short-u': 'Short u', 'digraph-ch': 'digraph ch',
          'digraph-sh': 'digraph sh', 'digraph-th-voiced': 'digraph th voiced',
          'digraph-th-voiceless': 'digraph th voiceless', 'digraph-ph': 'digraph ph',
          'consonant-y': 'consonant y'
        };

        const ArrowUp = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="12" y1="19" x2="12" y2="5"/><polyline points="5 12 12 5 19 12"/></svg>;
        const Users = ({size=20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>;
        const Settings = ({size=18}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="3"/><path d="M12 1v6m0 6v6m9-9h-6m-6 0H3"/></svg>;
        const Copy = ({size=16}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>;
        const Check = ({size=16}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="20 6 9 17 4 12"/></svg>;
        const Wifi = ({size=20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M5 12.55a11 11 0 0 1 14.08 0"/><path d="M1.42 9a16 16 0 0 1 21.16 0"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><line x1="12" y1="20" x2="12.01" y2="20"/></svg>;
        const WifiOff = ({size=16}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="1" y1="1" x2="23" y2="23"/><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"/><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"/></svg>;

        const GoFishPhonics = () => {
          const [gameState, setGameState] = useState('setup');
          const [myPeerId, setMyPeerId] = useState('');
          const [opponentPeerId, setOpponentPeerId] = useState('');
          const [playerName, setPlayerName] = useState('');
          const [opponentName, setOpponentName] = useState('');
          const [settings, setSettings] = useState({
            endTurnMode: 'always-draw',
            selectedSets: Object.keys(CARD_SETS),
            firstPlayer: 'host'
          });
          const [copied, setCopied] = useState(false);
          const [connected, setConnected] = useState(false);
          const [isHost, setIsHost] = useState(false);
          const [deck, setDeck] = useState([]);
          const [myHand, setMyHand] = useState([]);
          const [opponentHandCount, setOpponentHandCount] = useState(0);
          const [mySets, setMySets] = useState([]);
          const [opponentSets, setOpponentSets] = useState([]);
          const [isMyTurn, setIsMyTurn] = useState(false);
          const [selectedCard, setSelectedCard] = useState(null);
          const [draggedCard, setDraggedCard] = useState(null);
          const [dragOverIndex, setDragOverIndex] = useState(null);
          const [myScore, setMyScore] = useState(0);
          const [opponentScore, setOpponentScore] = useState(0);
          const [deckCount, setDeckCount] = useState(0);
          const [gameEnded, setGameEnded] = useState(false);
          const [winner, setWinner] = useState(null);
          const [showAllCards, setShowAllCards] = useState(false);
          const [showSets, setShowSets] = useState(false);
          const [disconnectMessage, setDisconnectMessage] = useState('');
          const [lastPingReceived, setLastPingReceived] = useState(Date.now());
          const [isMyTurnToPing, setIsMyTurnToPing] = useState(false);
          const peerRef = useRef(null);
          const connRef = useRef(null);
          const deckRef = useRef([]);
          const isHostRef = useRef(false);  

          useEffect(() => {
            if (window.Peer) initializePeer();
            else {
              const checkPeer = setInterval(() => {
                if (window.Peer) { clearInterval(checkPeer); initializePeer(); }
              }, 100);
              setTimeout(() => { clearInterval(checkPeer); if (!window.Peer) alert('Failed to load networking library.'); }, 5000);
            }
            return () => { if (peerRef.current) peerRef.current.destroy(); };
          }, []);

          const initializePeer = () => {
            const urlParams = new URLSearchParams(window.location.search);
            const joinId = urlParams.get('join');
            if (joinId) {
              const peer = new window.Peer();
              peerRef.current = peer;
              peer.on('open', (id) => { setMyPeerId(id); setOpponentPeerId(joinId); setIsHost(false); isHostRef.current = false; });  
            } else {
              const peer = new window.Peer();
              peerRef.current = peer;
              peer.on('open', (id) => { setMyPeerId(id); setIsHost(true); isHostRef.current = true; });  
              peer.on('connection', (conn) => setupConnection(conn));
            }
          };

          const setupConnection = (conn) => {
            connRef.current = conn;
            conn.on('open', () => {
              console.log('Connection opened');
              setConnected(true);
            });
            conn.on('data', (data) => handleIncomingData(data));
            conn.on('close', () => { 
              console.log('Connection closed - opponent disconnected');
              setConnected(false); 
              setGameEnded(true);
              setDisconnectMessage(`${opponentName || 'Your opponent'} has disconnected. The game has ended. You may close this window.`);
            });
            conn.on('error', (err) => {
              console.error('Connection error:', err);
            });
          };

          const connectToOpponent = () => {
            if (!playerName.trim()) { alert('Please enter your name'); return; }
            if (!opponentPeerId) { alert('Invalid connection'); return; }
            const conn = peerRef.current.connect(opponentPeerId);
            connRef.current = conn;
            conn.on('open', () => { 
              console.log('Guest connected, sending name:', playerName);
              setConnected(true); 
              conn.send({ type: 'player-info', name: playerName });
            });
            conn.on('data', (data) => handleIncomingData(data));
            conn.on('close', () => { 
              console.log('Connection closed - host disconnected');
              setConnected(false); 
              setGameEnded(true);
              setDisconnectMessage(`${opponentName || 'The host'} has disconnected. The game has ended. You may close this window.`);
            });
            conn.on('error', (err) => {
              console.error('Connection error:', err);
            });
          };

          const sendData = (data) => { if (connRef.current?.open) connRef.current.send(data); };

          const handleIncomingData = (data) => {
            console.log('Received data:', data);
            switch (data.type) {
              case 'player-info': 
                console.log('Received player-info, setting opponent name to:', data.name);
                setOpponentName(data.name);
                if (!data.isResponse) {
                  console.log('Sending player-info response with name:', playerName);
                  sendData({ type: 'player-info', name: playerName, isResponse: true }); 
                }
                break;
              case 'ping':
                console.log('Received ping from opponent');
                setLastPingReceived(Date.now());
                sendData({ type: 'pong' });
                break;
              case 'pong':
                console.log('Received pong from opponent');
                setLastPingReceived(Date.now());
                setIsMyTurnToPing(true);
                break;
             case 'start-game': 
                setSettings(data.settings); 
                setDeck([]); // Opponent doesn't hold the deck
                setMyHand(data.opponentHand); 
                setOpponentHandCount(data.playerHandCount); 
                setDeckCount(data.deckCount); 
                setIsMyTurn(!data.hostStarts);
                setIsMyTurnToPing(!data.hostStarts);
                setLastPingReceived(Date.now());
                if (data.hostName) setOpponentName(data.hostName);
                setGameState('playing'); 
                break;
              case 'card-drawn': setDeckCount(data.deckCount); setOpponentHandCount(data.handCount); setIsMyTurn(true); break;
              case 'draw-request': 
                console.log('Host received draw-request, isHostRef:', isHostRef.current, 'deckRef.length:', deckRef.current.length);
                if (isHostRef.current && deckRef.current.length > 0) {
                  const newDeck = [...deckRef.current];
                  const drawnCard = newDeck.pop();
                  console.log('Host dealing card to opponent:', drawnCard);
                  setDeck(newDeck);
                  deckRef.current = newDeck;
                  setDeckCount(newDeck.length);
                  setOpponentHandCount(opponentHandCount + 1);
                  sendData({ type: 'card-dealt', card: drawnCard, deckCount: newDeck.length });
                } else if (isHostRef.current && deckRef.current.length === 0) {
                  console.log('Deck is empty, notifying opponent');
                  sendData({ type: 'deck-empty' });
                } else {
                  console.log('NOT handling draw-request - isHostRef:', isHostRef.current, 'deckRef.length:', deckRef.current.length);
                }
                break;            
              case 'deck-empty':
                if (settings.endTurnMode === 'always-draw') setIsMyTurn(false);
                break;
              case 'card-dealt':
                setMyHand(prevHand => [...prevHand, data.card]);
                setDeckCount(data.deckCount);
                if (settings.endTurnMode === 'always-draw') {
                  setIsMyTurn(false);
                  sendData({ type: 'turn-ended' });
                }
                break;
              case 'card-given': 
                setMyHand(prevHand => [...prevHand, data.card]); 
                setOpponentHandCount(data.senderHandCount); 
                break;      
              case 'hand-replenished': setOpponentHandCount(data.handCount); setDeckCount(data.deckCount); break;
              case 'set-completed': 
                setOpponentSets(prevSets => [...prevSets, data.set]); 
                setOpponentScore(prevScore => prevScore + 1); 
                setOpponentHandCount(data.remainingCards); 
                break;
              case 'turn-ended': setIsMyTurn(true); break;                   
              case 'game-over':
                // Receive opponent's final scores
                const opponentFinalScore = data.finalMyScore;
                const myFinalScore = data.finalOpponentScore;
                
                // Determine winner based on opponent's reported scores
                // (their "my score" is our "opponent score" and vice versa)
                if (myFinalScore > opponentFinalScore) {
                  setWinner('you');
                } else if (opponentFinalScore > myFinalScore) {
                  setWinner('opponent');
                } else {
                  setWinner('tie');
                }
                
                // Update scores to match
                setMyScore(myFinalScore);
                setOpponentScore(opponentFinalScore);
                setGameEnded(true);
                break;      
              case 'return-to-setup':
                setGameState('setup');
                setGameEnded(false);
                setWinner(null);
                setMyHand([]);
                setOpponentHandCount(0);
                setMySets([]);
                setOpponentSets([]);
                setMyScore(0);
                setOpponentScore(0);
                setDeck([]);
                setDeckCount(0);
                break;
                }
               };

          const shuffleArray = (arr) => { const a = [...arr]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; };
          const initializeDeck = () => { const cards = []; settings.selectedSets.forEach(sk => CARD_SETS[sk].forEach(c => cards.push({ id: `${sk}-${c}`, set: sk, name: c }))); return shuffleArray(cards); };

          const startGame = () => {
            if (!playerName.trim()) { alert('Please enter your name'); return; }
            if (!connected) { alert('Waiting for opponent'); return; }
            console.log('startGame called, isHost:', isHost);
            sendData({ type: 'player-info', name: playerName });
            const newDeck = initializeDeck();
            console.log('Deck initialized with', newDeck.length, 'cards');
            const hostHand = newDeck.slice(0, 4), guestHand = newDeck.slice(4, 8), remaining = newDeck.slice(8);
            console.log('Host gets', hostHand.length, 'cards, guest gets', guestHand.length, 'cards, deck has', remaining.length, 'cards');
            const hostGoesFirst = settings.firstPlayer === 'host';
            setDeck(remaining); deckRef.current = remaining; setMyHand(hostHand); setOpponentHandCount(4); setDeckCount(remaining.length); setIsMyTurn(hostGoesFirst); setIsMyTurnToPing(hostGoesFirst); setLastPingReceived(Date.now()); setGameState('playing');  
            sendData({ type: 'start-game', settings, deck: remaining, playerHandCount: 4, opponentHand: guestHand, deckCount: remaining.length, hostStarts: hostGoesFirst, hostName: playerName });
          };
            
           // Ping system: alternating pings every 1 second
          useEffect(() => {
            if (gameState !== 'playing' || !connected) return;
            
            const pingInterval = setInterval(() => {
              if (isMyTurnToPing) {
                console.log('Sending ping to opponent');
                sendData({ type: 'ping' });
                setIsMyTurnToPing(false);
              }
              
              // Check if we haven't received a ping/pong in 3 seconds
              const timeSinceLastPing = Date.now() - lastPingReceived;
              if (timeSinceLastPing > 3000) {
                console.log('No response from opponent for 3 seconds - disconnected');
                setConnected(false);
                setGameEnded(true);
                setDisconnectMessage(`${opponentName || 'Your opponent'} has disconnected. The game has ended. You may close this window.`);
              }
            }, 1000);
            
            return () => clearInterval(pingInterval);
          }, [gameState, connected, isMyTurnToPing, lastPingReceived, opponentName]);

          const drawCard = () => {
            console.log('drawCard called, deckCount:', deckCount, 'isHost:', isHost);
            if (deckCount === 0) { if (settings.endTurnMode === 'always-draw') endTurn(); return; }
            
            if (isHost) {
              // Host draws directly from their deck
              const newDeck = [...deckRef.current];
              const drawnCard = newDeck.pop();
              console.log('Host drawing card:', drawnCard);
              setMyHand([...myHand, drawnCard]);
              setDeck(newDeck);
              deckRef.current = newDeck;                  
              setDeckCount(newDeck.length);
              sendData({ type: 'card-drawn', deckCount: newDeck.length, handCount: myHand.length + 1 });
              if (settings.endTurnMode === 'always-draw') endTurn();
            } else {
              // Opponent requests a card from host
              console.log('Opponent requesting card from host');
              sendData({ type: 'draw-request' });
            }
          };

          const replenishHand = (hand) => {
            if (deckCount === 0 || hand.length >= 4) return hand;
            
            if (isHost) {
              const newDeck = [...deckRef.current], newHand = [...hand];
              while (newHand.length < 4 && newDeck.length > 0) newHand.push(newDeck.pop());
              setDeck(newDeck);
              deckRef.current = newDeck;
              setDeckCount(newDeck.length);                  
              sendData({ type: 'hand-replenished', handCount: newHand.length, deckCount: newDeck.length });
              return newHand;
            } else {
              // For opponent, request cards from host until hand is full
              const cardsNeeded = 4 - hand.length;
              for (let i = 0; i < cardsNeeded && deckCount > 0; i++) {
                sendData({ type: 'draw-request' });
              }
              return hand; // Hand will be updated as cards arrive
            }
          };
  
          const giveCard = () => {
            if (!selectedCard) return;
            const newMyHand = myHand.filter(c => c.id !== selectedCard.id);
            sendData({ type: 'card-given', card: selectedCard, senderHandCount: newMyHand.length });
            setMyHand(replenishHand(newMyHand)); setSelectedCard(null);
          };

          const endTurn = () => { setIsMyTurn(false); setSelectedCard(null); sendData({ type: 'turn-ended' }); };
          const checkForSets = (hand) => {
            // Check for 4 consecutive cards of the same set
            for (let i = 0; i <= hand.length - 4; i++) {
              const fourCards = hand.slice(i, i + 4);
              const firstSet = fourCards[0].set;
              
              // Check if all 4 consecutive cards are from the same set
              if (fourCards.every(card => card.set === firstSet)) {
                completeSet(firstSet, hand);
                return true;
              }
            }
            return false;
          };  

          const completeSet = (setKey, hand) => {
            const setCards = hand.filter(c => c.set === setKey);
            const remainingCards = hand.filter(c => c.set !== setKey);
            
            // Replenish hand immediately after completing set
            const replenishedHand = replenishHand(remainingCards);
            
            setMyHand(replenishedHand);
            setMySets([...mySets, { set: setKey, cards: setCards }]);
            setMyScore(myScore + 1);
            sendData({ type: 'set-completed', set: { set: setKey, cards: setCards }, remainingCards: replenishedHand.length });
          };
            
          useEffect(() => { if (myHand.length > 0) checkForSets(myHand); }, [myHand]);

          // Check for game over condition
          useEffect(() => {
            if (gameState === 'playing' && deckCount === 0 && myHand.length === 0 && opponentHandCount === 0 && !gameEnded) {
              setGameEnded(true);
              sendData({ type: 'game-over', finalMyScore: myScore, finalOpponentScore: opponentScore, senderName: playerName });
            }
          }, [deckCount, myHand.length, opponentHandCount, myScore, opponentScore, gameState, gameEnded]);
                       
          const handleDragStart = (e, card, index) => setDraggedCard({ card, index });
          const handleDragOver = (e, index) => { e.preventDefault(); setDragOverIndex(index); };
          const handleDrop = (e, dropIndex) => {
            e.preventDefault();
            if (draggedCard === null) return;
            const newHand = [...myHand];
            const [removed] = newHand.splice(draggedCard.index, 1);
            newHand.splice(dropIndex, 0, removed);
            setMyHand(newHand); setDraggedCard(null); setDragOverIndex(null);
            sendData({ type: 'hand-reordered' });
          };

          const copyInviteLink = () => {
            navigator.clipboard.writeText(`${window.location.origin}${window.location.pathname}?join=${myPeerId}`);
            setCopied(true); setTimeout(() => setCopied(false), 2000);
          };

          if (gameState === 'setup') {
            return (
              <div className="w-full min-h-screen bg-gradient-to-b from-blue-100 to-blue-200 p-8 flex items-center justify-center">
                <div className="bg-white rounded-lg shadow-xl p-12 max-w-5xl w-full" style={{margin: '3cm'}}>
                  <h1 className="text-4xl font-bold text-center text-blue-600 mb-8">Go-Fish Phonics</h1>
                  {!myPeerId ? (
                    <div className="text-center"><div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div><p className="mt-4 text-gray-600">Connecting...</p></div>
                  ) : (
                    <div className="space-y-6">
                      <div className="grid grid-cols-2 gap-6">
                        <div><label className="block text-sm font-medium text-gray-700 mb-2">Your Name</label><input type="text" value={playerName} onChange={(e) => setPlayerName(e.target.value)} className="w-full px-4 py-2 border border-gray-300 rounded-lg" placeholder="Enter your name" /></div>
                        {isHost && (
                          <div><label className="block text-sm font-medium text-gray-700 mb-2">Turn End Mode</label><select value={settings.endTurnMode} onChange={(e) => setSettings({...settings, endTurnMode: e.target.value})} className="w-full px-4 py-2 border border-gray-300 rounded-lg"><option value="always-draw">Classic Mode</option><option value="manual-end">Strategic Mode</option></select></div>
                        )}
                      </div>
                      {isHost && (
                        <div><label className="block text-sm font-medium text-gray-700 mb-2">Who Goes First?</label><select value={settings.firstPlayer} onChange={(e) => setSettings({...settings, firstPlayer: e.target.value})} className="w-full px-4 py-2 border border-gray-300 rounded-lg"><option value="host">Host (You)</option><option value="opponent">Opponent</option></select></div>
                      )}
                      {isHost && (
                        <div><label className="block text-sm font-medium text-gray-700 mb-2"><Settings size={18} /> Select Card Sets</label><div className="bg-gray-50 p-4 rounded-lg"><div className="grid grid-cols-4 gap-3 text-sm">{Object.entries(SET_NAMES).map(([key, name]) => (<div key={key} className="flex items-center"><input type="checkbox" checked={settings.selectedSets.includes(key)} onChange={(e) => { if (e.target.checked) setSettings({...settings, selectedSets: [...settings.selectedSets, key]}); else setSettings({...settings, selectedSets: settings.selectedSets.filter(s => s !== key)}); }} className="mr-2" />{name}</div>))}</div></div></div>
                      )}
                      {isHost && (
                        <div className="bg-blue-50 border-2 border-blue-300 rounded-lg p-4"><div className="flex items-center justify-between mb-2"><div className="flex items-center gap-2"><Users size={20} /><span className="font-semibold text-blue-900">Invite Opponent</span></div><div className="flex items-center gap-3"><div className="px-3 py-1 bg-white border border-gray-300 rounded text-sm">{connected && opponentName ? opponentName : 'No connection'}</div>{connected ? <span className="text-green-600 text-sm flex items-center gap-1"><Wifi size={16} /> Connected</span> : <span className="text-orange-600 text-sm flex items-center gap-1"><WifiOff size={16} /> Waiting...</span>}</div></div><p className="text-sm text-gray-700 mb-3">Share this link:</p><div className="flex gap-2"><input type="text" value={`${window.location.origin}${window.location.pathname}?join=${myPeerId}`} readOnly className="flex-1 px-3 py-2 bg-white border border-gray-300 rounded text-sm" /><button onClick={copyInviteLink} className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 flex items-center gap-2">{copied ? <Check size={16} /> : <Copy size={16} />}{copied ? 'Copied!' : 'Copy'}</button></div></div>
                      )}
                      {!isHost && (<div className="bg-green-50 border-2 border-green-300 rounded-lg p-4"><p className="text-green-900 font-semibold mb-2">Joining game...</p><p className="text-sm text-gray-700">Click Connect</p>{connected && <p className="text-green-600 text-sm mt-2 flex items-center gap-1"><Wifi size={16} /> Connected! Waiting for host...</p>}</div>)}
                      {isHost ? (<button onClick={startGame} disabled={!connected} className={`w-full py-3 rounded-lg font-semibold ${connected ? 'bg-blue-600 text-white hover:bg-blue-700' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}>{connected ? 'Start Game' : 'Waiting for Opponent...'}</button>) : (<button onClick={connectToOpponent} disabled={false} className="w-full py-3 rounded-lg font-semibold bg-green-600 text-white hover:bg-green-700">{connected ? 'Connected - Waiting for Host...' : 'Connect to Game'}</button>)}  
                    </div>
                  )}
                </div>
              </div>
            );
          }

          return (
            <div className="w-full h-screen bg-gradient-to-b from-green-100 to-green-200 flex flex-col">
              {gameEnded && disconnectMessage && (
                <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                  <div className="bg-white rounded-lg shadow-2xl p-8 max-w-md text-center">
                    <h2 className="text-2xl font-bold text-red-600 mb-4">Game Ended</h2>
                    <p className="text-gray-700 mb-6">{disconnectMessage}</p>
                  </div>
                </div>
              )}
                {showAllCards && (
                <div className="absolute inset-0 z-50 flex items-center justify-end">
                  {/* Dark overlay only on the right 2/3 */}
                  <div className="absolute inset-0 bg-black bg-opacity-50" style={{left: '33.33%'}} onClick={() => setShowAllCards(false)}></div>
                  
                  {/* Modal positioned on right 2/3 with margin from preview */}
                  <div className="bg-white rounded-lg shadow-2xl p-6 max-h-[90vh] overflow-y-auto relative" style={{width: '66.66%', marginLeft: '38px'}} onDragOver={(e) => {
                    e.preventDefault();
                    const container = e.currentTarget;
                    const rect = container.getBoundingClientRect();
                    const scrollThreshold = 100;
                    const scrollSpeed = 10;
                    
                    if (e.clientY < rect.top + scrollThreshold) {
                      container.scrollTop -= scrollSpeed;
                    } else if (e.clientY > rect.bottom - scrollThreshold) {
                      container.scrollTop += scrollSpeed;
                    }
                  }}>  
                    <div className="flex justify-between items-center mb-4">
                      <h2 className="text-2xl font-bold">Your Hand - Organize Your Cards</h2>
                      <button 
                        onClick={() => setShowAllCards(false)}
                        className="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600"
                      >
                        Close
                      </button>
                    </div>
                    <div className="grid grid-cols-4 gap-4">
                      {myHand.map((card, i) => (
                        <div 
                          key={card.id} 
                          draggable 
                          onDragStart={(e) => handleDragStart(e, card, i)} 
                          onDragOver={(e) => handleDragOver(e, i)} 
                          onDrop={(e) => handleDrop(e, i)} 
                          onClick={() => setSelectedCard(selectedCard?.id === card.id ? null : card)} 
                          className={`w-44 h-60 rounded-lg shadow-lg border-4 cursor-pointer relative ${selectedCard?.id === card.id ? 'border-yellow-400' : 'border-white'} ${dragOverIndex === i ? 'ring-4 ring-blue-400' : ''}`}
                        >
                          <img src={CARD_IMAGES[card.id]} alt={card.name} className="w-full h-full object-cover rounded-lg" />
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              )}
              {showSets && (
                <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                  <div className="bg-white rounded-lg shadow-2xl p-6 max-w-6xl max-h-[90vh] overflow-y-auto">
                    <div className="flex justify-between items-center mb-6">
                      <h2 className="text-2xl font-bold">Completed Sets</h2>
                      <button 
                        onClick={() => setShowSets(false)}
                        className="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600"
                      >
                        Close
                      </button>
                    </div>
                    
                    {/* Player's Sets */}
                    <div className="mb-8">
                      <h3 className="text-xl font-semibold mb-4 text-blue-600">{playerName}'s Sets ({myScore})</h3>
                      {mySets.length === 0 ? (
                        <p className="text-gray-500 italic">No sets completed yet</p>
                      ) : (
                        <div className="grid grid-cols-3 gap-6">
                          {mySets.map((set, i) => (
                            <div key={i} className="bg-blue-50 p-4 rounded-lg border-2 border-blue-300">
                              <div className="text-sm font-semibold mb-2 text-center">{SET_NAMES[set.set]}</div>
                              <div className="grid grid-cols-4 gap-2">
                                {set.cards.map((card, j) => (
                                  <img 
                                    key={j} 
                                    src={CARD_IMAGES[card.id]} 
                                    alt={card.name} 
                                    className="w-16 h-22 rounded border-2 border-blue-600 object-cover"
                                  />
                                ))}
                              </div>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                    
                    {/* Opponent's Sets */}
                    <div>
                      <h3 className="text-xl font-semibold mb-4 text-red-600">{opponentName}'s Sets ({opponentScore})</h3>
                      {opponentSets.length === 0 ? (
                        <p className="text-gray-500 italic">No sets completed yet</p>
                      ) : (
                        <div className="grid grid-cols-3 gap-6">
                          {opponentSets.map((set, i) => (
                            <div key={i} className="bg-red-50 p-4 rounded-lg border-2 border-red-300">
                              <div className="text-sm font-semibold mb-2 text-center">{SET_NAMES[set.set]}</div>
                              <div className="grid grid-cols-4 gap-2">
                                {set.cards.map((card, j) => (
                                  <img 
                                    key={j} 
                                    src={CARD_IMAGES[card.id]} 
                                    alt={card.name} 
                                    className="w-16 h-22 rounded border-2 border-red-600 object-cover"
                                  />
                                ))}
                              </div>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              )}
               {gameEnded && !disconnectMessage && winner && (
                <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                  <div className="bg-white rounded-lg shadow-2xl p-8 max-w-md text-center">
                    <h2 className="text-3xl font-bold mb-4">
                      {winner === 'you' ? 'üéâ You Win! üéâ' : winner === 'opponent' ? 'üòî You Lose' : 'ü§ù It\'s a Tie!'}
                    </h2>
                    <div className="text-xl mb-6">
                      <p className="mb-2">Final Score:</p>
                      <p className="font-bold">{playerName}: {myScore}</p>
                      <p className="font-bold">{opponentName}: {opponentScore}</p>
                    </div>
                    <p className="text-gray-600 text-sm mb-4">
                      {isHost ? 'Return to setup to start a new game or change settings.' : 'Waiting for host to start a new game...'}
                    </p>
                    <button 
                      onClick={() => {
                        setGameState('setup');
                        setGameEnded(false);
                        setWinner(null);
                        setMyHand([]);
                        setOpponentHandCount(0);
                        setMySets([]);
                        setOpponentSets([]);
                        setMyScore(0);
                        setOpponentScore(0);
                        setDeck([]);
                        setDeckCount(0);
                        sendData({ type: 'return-to-setup' });
                      }} 
                      className="px-6 py-3 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700"
                    >
                      Return to Setup
                    </button>
                  </div>
                </div>
              )}
                {/* Top left corner - Turn indicator */}
                <div className={`absolute top-4 left-4 bg-white shadow-lg rounded-lg p-3 z-20 ${isMyTurn ? 'animate-pulse border-2 border-yellow-400' : 'border-2 border-gray-300'}`}>
                  <div className="text-sm font-semibold text-gray-600 mb-1">{playerName || 'Your'}'s Hand</div>
                  <div className="text-lg font-bold">{isMyTurn ? "Your Turn" : `${opponentName || "Opponent"}'s Turn`}</div>
                </div>
                
                {/* Top right corner - Score tracker */}
                <div className="absolute top-4 right-4 bg-white shadow-lg rounded-lg p-3 z-20 border-2 border-gray-300">
                  <div className="flex gap-6">
                    <div className="text-center">
                      <div className="text-xs text-gray-600 mb-1">{playerName}</div>
                      <div className="text-2xl font-bold text-blue-600">{myScore}</div>
                    </div>
                    <div className="text-center">
                      <div className="text-xs text-gray-600 mb-1">{opponentName}</div>
                      <div className="text-2xl font-bold text-red-600">{opponentScore}</div>
                    </div>
                  </div>
                </div>
                <div className="flex-1 p-4 flex items-start justify-center"><div className="flex gap-2">{Array(4).fill(0).map((_, i) => (<div key={i} className="w-20 h-28 bg-blue-500 rounded-lg shadow-lg border-4 border-blue-700" />))}</div></div>
              <div className="flex justify-center items-center py-4"><div className="text-center"><button onClick={drawCard} disabled={!isMyTurn || deckCount === 0} className={`w-24 h-32 rounded-lg shadow-xl border-4 font-bold text-white text-xl ${deckCount > 0 ? 'bg-purple-600 border-purple-800 hover:bg-purple-700' : 'bg-gray-400 border-gray-600'} ${!isMyTurn || deckCount === 0 ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}`}>{deckCount}</button><div className="text-sm mt-2 font-semibold">Deck</div></div>{settings.endTurnMode === 'manual-end' && (<button onClick={endTurn} disabled={!isMyTurn} className={`ml-8 px-6 py-3 rounded-lg font-semibold ${isMyTurn ? 'bg-orange-500 hover:bg-orange-600 text-white' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}>End Turn</button>)}</div>
              <div className="flex-1 p-4 flex items-end justify-center relative">
                {/* Left side - Enlarged card preview (absolute positioned) */}
                {selectedCard && (
                  <div className="absolute left-8 z-10" style={{bottom: 'calc(4rem + 56px)'}}>
                    <div className="relative">
                      <img 
                        src={CARD_IMAGES[selectedCard.id]} 
                        alt={selectedCard.name} 
                        className="rounded-lg shadow-2xl border-4 border-yellow-400"
                        style={{width: '335px', height: '430px'}}
                      />                        
                      <button 
                        onClick={(e) => { e.stopPropagation(); giveCard(); }} 
                        className="absolute -top-10 left-1/2 transform -translate-x-1/2 bg-red-500 text-white rounded-full p-3 hover:bg-red-600 shadow-lg"
                      >
                        <ArrowUp />
                      </button>
                    </div>
                  </div>
                )}
                                
                {/* Center - Player's hand with scrollable container */}
                <div className="flex flex-col items-center gap-2 max-w-4xl">
                  <div className="flex gap-2">
                    <button 
                      onClick={() => setShowAllCards(!showAllCards)}
                      className="px-4 py-2 bg-blue-500 text-white rounded-lg text-sm font-semibold hover:bg-blue-600 shadow"
                    >
                      {showAllCards ? 'Close Hand View' : 'View All Cards'}
                    </button>
                    <button 
                      onClick={() => setShowSets(!showSets)}
                      className="px-4 py-2 bg-green-500 text-white rounded-lg text-sm font-semibold hover:bg-green-600 shadow"
                    >
                      View Sets ({myScore + opponentScore})
                    </button>
                  </div>                 
                  {/* Scrollable hand */}
                  <div className="overflow-x-auto flex gap-2 px-4 max-w-full" style={{maxWidth: '800px'}}>
                    {myHand.map((card, i) => (
                      <div 
                        key={card.id} 
                        draggable 
                        onDragStart={(e) => handleDragStart(e, card, i)} 
                        onDragOver={(e) => handleDragOver(e, i)} 
                        onDrop={(e) => handleDrop(e, i)} 
                        onClick={() => setSelectedCard(selectedCard?.id === card.id ? null : card)} 
                        className={`w-44 h-60 rounded-lg shadow-lg border-4 cursor-pointer relative flex-shrink-0 ${selectedCard?.id === card.id ? 'border-yellow-400' : 'border-white'} ${dragOverIndex === i ? 'ring-4 ring-blue-400' : ''}`}
                      >
                        <img src={CARD_IMAGES[card.id]} alt={card.name} className="w-full h-full object-cover rounded-lg" />
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            </div>
          );
        };

        ReactDOM.render(<GoFishPhonics />, document.getElementById('root'));    

    </script>
</body>
</html>







































