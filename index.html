<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Go-Fish Phonics</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.4/peerjs.min.js"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const CARD_SETS = {
          'short-a': ['apple', 'ant', 'hat', 'crab'],
          'short-e': ['egg', 'pen', 'bed', 'web'],
          'short-i': ['igloo', 'pin', 'fish', 'milk'],
          'short-o': ['octopus', 'fox', 'mop', 'clock'],
          'short-u': ['umbrella', 'bug', 'cup', 'sun'],
          'digraph-ch': ['chair', 'cherry', 'church', 'cheese'],
          'digraph-sh': ['ship', 'shell', 'sheep', 'shoe'],
          'digraph-th-voiced': ['this', 'that', 'those', 'ther'],
          'digraph-th-voiceless': ['think', 'thumb', 'three', 'thin'],
          'digraph-ph': ['phone', 'photo', 'elephant', 'graph'],
          'consonant-y': ['yellow', 'yoyo', 'yard', 'yell']
        };

        const SET_NAMES = {
          'short-a': 'Short A', 'short-e': 'Short E', 'short-i': 'Short I',
          'short-o': 'Short O', 'short-u': 'Short U', 'digraph-ch': 'CH',
          'digraph-sh': 'SH', 'digraph-th-voiced': 'TH (voiced)',
          'digraph-th-voiceless': 'TH (voiceless)', 'digraph-ph': 'PH',
          'consonant-y': 'Y'
        };

        const ArrowUp = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="12" y1="19" x2="12" y2="5"/><polyline points="5 12 12 5 19 12"/></svg>;
        const Users = ({size=20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>;
        const Settings = ({size=18}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="3"/><path d="M12 1v6m0 6v6m9-9h-6m-6 0H3"/></svg>;
        const Copy = ({size=16}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>;
        const Check = ({size=16}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="20 6 9 17 4 12"/></svg>;
        const Wifi = ({size=20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M5 12.55a11 11 0 0 1 14.08 0"/><path d="M1.42 9a16 16 0 0 1 21.16 0"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><line x1="12" y1="20" x2="12.01" y2="20"/></svg>;
        const WifiOff = ({size=16}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="1" y1="1" x2="23" y2="23"/><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"/><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"/></svg>;

        const GoFishPhonics = () => {
          const [gameState, setGameState] = useState('setup');
          const [myPeerId, setMyPeerId] = useState('');
          const [opponentPeerId, setOpponentPeerId] = useState('');
          const [playerName, setPlayerName] = useState('');
          const [opponentName, setOpponentName] = useState('');
          const [settings, setSettings] = useState({
            endTurnMode: 'always-draw',
            selectedSets: Object.keys(CARD_SETS),
            firstPlayer: 'host'
          });
          const [copied, setCopied] = useState(false);
          const [connected, setConnected] = useState(false);
          const [isHost, setIsHost] = useState(false);
          const [deck, setDeck] = useState([]);
          const [myHand, setMyHand] = useState([]);
          const [opponentHandCount, setOpponentHandCount] = useState(0);
          const [mySets, setMySets] = useState([]);
          const [opponentSets, setOpponentSets] = useState([]);
          const [isMyTurn, setIsMyTurn] = useState(false);
          const [selectedCard, setSelectedCard] = useState(null);
          const [draggedCard, setDraggedCard] = useState(null);
          const [dragOverIndex, setDragOverIndex] = useState(null);
          const [myScore, setMyScore] = useState(0);
          const [opponentScore, setOpponentScore] = useState(0);
          const [deckCount, setDeckCount] = useState(0);
          const [gameEnded, setGameEnded] = useState(false);
          const [disconnectMessage, setDisconnectMessage] = useState('');
          const [lastPingReceived, setLastPingReceived] = useState(Date.now());
          const [isMyTurnToPing, setIsMyTurnToPing] = useState(false);
          const peerRef = useRef(null);
          const connRef = useRef(null);
          const deckRef = useRef([]);
          const isHostRef = useRef(false);  

          useEffect(() => {
            if (window.Peer) initializePeer();
            else {
              const checkPeer = setInterval(() => {
                if (window.Peer) { clearInterval(checkPeer); initializePeer(); }
              }, 100);
              setTimeout(() => { clearInterval(checkPeer); if (!window.Peer) alert('Failed to load networking library.'); }, 5000);
            }
            return () => { if (peerRef.current) peerRef.current.destroy(); };
          }, []);

          const initializePeer = () => {
            const urlParams = new URLSearchParams(window.location.search);
            const joinId = urlParams.get('join');
            if (joinId) {
              const peer = new window.Peer();
              peerRef.current = peer;
              peer.on('open', (id) => { setMyPeerId(id); setOpponentPeerId(joinId); setIsHost(false); isHostRef.current = false; });  
            } else {
              const peer = new window.Peer();
              peerRef.current = peer;
              peer.on('open', (id) => { setMyPeerId(id); setIsHost(true); isHostRef.current = true; });  
              peer.on('connection', (conn) => setupConnection(conn));
            }
          };

          const setupConnection = (conn) => {
            connRef.current = conn;
            conn.on('open', () => {
              console.log('Connection opened');
              setConnected(true);
            });
            conn.on('data', (data) => handleIncomingData(data));
            conn.on('close', () => { 
              console.log('Connection closed - opponent disconnected');
              setConnected(false); 
              setGameEnded(true);
              setDisconnectMessage(`${opponentName || 'Your opponent'} has disconnected. The game has ended. You may close this window.`);
            });
            conn.on('error', (err) => {
              console.error('Connection error:', err);
            });
          };

          const connectToOpponent = () => {
            if (!playerName.trim()) { alert('Please enter your name'); return; }
            if (!opponentPeerId) { alert('Invalid connection'); return; }
            const conn = peerRef.current.connect(opponentPeerId);
            connRef.current = conn;
            conn.on('open', () => { 
              console.log('Guest connected, sending name:', playerName);
              setConnected(true); 
              conn.send({ type: 'player-info', name: playerName });
            });
            conn.on('data', (data) => handleIncomingData(data));
            conn.on('close', () => { 
              console.log('Connection closed - host disconnected');
              setConnected(false); 
              setGameEnded(true);
              setDisconnectMessage(`${opponentName || 'The host'} has disconnected. The game has ended. You may close this window.`);
            });
            conn.on('error', (err) => {
              console.error('Connection error:', err);
            });
          };

          const sendData = (data) => { if (connRef.current?.open) connRef.current.send(data); };

          const handleIncomingData = (data) => {
            console.log('Received data:', data);
            switch (data.type) {
              case 'player-info': 
                console.log('Received player-info, setting opponent name to:', data.name);
                setOpponentName(data.name);
                if (!data.isResponse) {
                  console.log('Sending player-info response with name:', playerName);
                  sendData({ type: 'player-info', name: playerName, isResponse: true }); 
                }
                break;
              case 'ping':
                console.log('Received ping from opponent');
                setLastPingReceived(Date.now());
                sendData({ type: 'pong' });
                break;
              case 'pong':
                console.log('Received pong from opponent');
                setLastPingReceived(Date.now());
                setIsMyTurnToPing(true);
                break;
             case 'start-game': 
                setSettings(data.settings); 
                setDeck([]); // Opponent doesn't hold the deck
                setMyHand(data.opponentHand); 
                setOpponentHandCount(data.playerHandCount); 
                setDeckCount(data.deckCount); 
                setIsMyTurn(!data.hostStarts);
                setIsMyTurnToPing(!data.hostStarts);
                setLastPingReceived(Date.now());
                if (data.hostName) setOpponentName(data.hostName);
                setGameState('playing'); 
                break;
              case 'card-drawn': setDeckCount(data.deckCount); setOpponentHandCount(data.handCount); setIsMyTurn(true); break;
              case 'draw-request': 
                console.log('Host received draw-request, isHostRef:', isHostRef.current, 'deckRef.length:', deckRef.current.length);
                if (isHostRef.current && deckRef.current.length > 0) {
                  const newDeck = [...deckRef.current];
                  const drawnCard = newDeck.pop();
                  console.log('Host dealing card to opponent:', drawnCard);
                  setDeck(newDeck);
                  deckRef.current = newDeck;
                  setDeckCount(newDeck.length);
                  setOpponentHandCount(opponentHandCount + 1);
                  sendData({ type: 'card-dealt', card: drawnCard, deckCount: newDeck.length });
                } else if (isHostRef.current && deckRef.current.length === 0) {
                  console.log('Deck is empty, notifying opponent');
                  sendData({ type: 'deck-empty' });
                } else {
                  console.log('NOT handling draw-request - isHostRef:', isHostRef.current, 'deckRef.length:', deckRef.current.length);
                }
                break;            
              case 'deck-empty':
                if (settings.endTurnMode === 'always-draw') setIsMyTurn(false);
                break;
              case 'card-dealt':
                setMyHand(prevHand => [...prevHand, data.card]);
                setDeckCount(data.deckCount);
                if (settings.endTurnMode === 'always-draw') {
                  setIsMyTurn(false);
                  sendData({ type: 'turn-ended' });
                }
                break;      
              case 'card-given': setMyHand([...myHand, data.card]); setOpponentHandCount(data.senderHandCount); break;
              case 'hand-replenished': setOpponentHandCount(data.handCount); setDeckCount(data.deckCount); break;
              case 'set-completed': setOpponentSets([...opponentSets, data.set]); setOpponentScore(opponentScore + 1); setOpponentHandCount(data.remainingCards); break;
              case 'turn-ended': setIsMyTurn(true); break;
            }
          };

          const shuffleArray = (arr) => { const a = [...arr]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; };
          const initializeDeck = () => { const cards = []; settings.selectedSets.forEach(sk => CARD_SETS[sk].forEach(c => cards.push({ id: `${sk}-${c}`, set: sk, name: c }))); return shuffleArray(cards); };

          const startGame = () => {
            if (!playerName.trim()) { alert('Please enter your name'); return; }
            if (!connected) { alert('Waiting for opponent'); return; }
            console.log('startGame called, isHost:', isHost);
            sendData({ type: 'player-info', name: playerName });
            const newDeck = initializeDeck();
            console.log('Deck initialized with', newDeck.length, 'cards');
            const hostHand = newDeck.slice(0, 4), guestHand = newDeck.slice(4, 8), remaining = newDeck.slice(8);
            console.log('Host gets', hostHand.length, 'cards, guest gets', guestHand.length, 'cards, deck has', remaining.length, 'cards');
            const hostGoesFirst = settings.firstPlayer === 'host';
            setDeck(remaining); deckRef.current = remaining; setMyHand(hostHand); setOpponentHandCount(4); setDeckCount(remaining.length); setIsMyTurn(hostGoesFirst); setIsMyTurnToPing(hostGoesFirst); setLastPingReceived(Date.now()); setGameState('playing');  
            sendData({ type: 'start-game', settings, deck: remaining, playerHandCount: 4, opponentHand: guestHand, deckCount: remaining.length, hostStarts: hostGoesFirst, hostName: playerName });
          };
            
           // Ping system: alternating pings every 1 second
          useEffect(() => {
            if (gameState !== 'playing' || !connected) return;
            
            const pingInterval = setInterval(() => {
              if (isMyTurnToPing) {
                console.log('Sending ping to opponent');
                sendData({ type: 'ping' });
                setIsMyTurnToPing(false);
              }
              
              // Check if we haven't received a ping/pong in 3 seconds
              const timeSinceLastPing = Date.now() - lastPingReceived;
              if (timeSinceLastPing > 3000) {
                console.log('No response from opponent for 3 seconds - disconnected');
                setConnected(false);
                setGameEnded(true);
                setDisconnectMessage(`${opponentName || 'Your opponent'} has disconnected. The game has ended. You may close this window.`);
              }
            }, 1000);
            
            return () => clearInterval(pingInterval);
          }, [gameState, connected, isMyTurnToPing, lastPingReceived, opponentName]);

          const drawCard = () => {
            console.log('drawCard called, deckCount:', deckCount, 'isHost:', isHost);
            if (deckCount === 0) { if (settings.endTurnMode === 'always-draw') endTurn(); return; }
            
            if (isHost) {
              // Host draws directly from their deck
              const newDeck = [...deckRef.current];
              const drawnCard = newDeck.pop();
              console.log('Host drawing card:', drawnCard);
              setMyHand([...myHand, drawnCard]);
              setDeck(newDeck);
              deckRef.current = newDeck;                  
              setDeckCount(newDeck.length);
              sendData({ type: 'card-drawn', deckCount: newDeck.length, handCount: myHand.length + 1 });
              if (settings.endTurnMode === 'always-draw') endTurn();
            } else {
              // Opponent requests a card from host
              console.log('Opponent requesting card from host');
              sendData({ type: 'draw-request' });
            }
          };

          const replenishHand = (hand) => {
            if (deckCount === 0 || hand.length >= 4) return hand;
            
            if (isHost) {
              const newDeck = [...deckRef.current], newHand = [...hand];
              while (newHand.length < 4 && newDeck.length > 0) newHand.push(newDeck.pop());
              setDeck(newDeck);
              deckRef.current = newDeck;
              setDeckCount(newDeck.length);                  
              sendData({ type: 'hand-replenished', handCount: newHand.length, deckCount: newDeck.length });
              return newHand;
            } else {
              // For opponent, request cards from host until hand is full
              const cardsNeeded = 4 - hand.length;
              for (let i = 0; i < cardsNeeded && deckCount > 0; i++) {
                sendData({ type: 'draw-request' });
              }
              return hand; // Hand will be updated as cards arrive
            }
          };
  
          const giveCard = () => {
            if (!selectedCard) return;
            const newMyHand = myHand.filter(c => c.id !== selectedCard.id);
            sendData({ type: 'card-given', card: selectedCard, senderHandCount: newMyHand.length });
            setMyHand(replenishHand(newMyHand)); setSelectedCard(null);
          };

          const endTurn = () => { setIsMyTurn(false); setSelectedCard(null); sendData({ type: 'turn-ended' }); };
          const checkForSets = (hand) => {
            const setCounts = {};
            hand.forEach(card => setCounts[card.set] = (setCounts[card.set] || 0) + 1);
            for (const [setKey, count] of Object.entries(setCounts)) {
              if (count === 4) { completeSet(setKey, hand); return true; }
            }
            return false;
          };

          const completeSet = (setKey, hand) => {
            const setCards = hand.filter(c => c.set === setKey), remainingCards = hand.filter(c => c.set !== setKey);
            setMyHand(remainingCards); setMySets([...mySets, { set: setKey, cards: setCards }]); setMyScore(myScore + 1);
            sendData({ type: 'set-completed', set: { set: setKey, cards: setCards }, remainingCards: remainingCards.length });
          };

          useEffect(() => { if (myHand.length > 0) checkForSets(myHand); }, [myHand]);

          const handleDragStart = (e, card, index) => setDraggedCard({ card, index });
          const handleDragOver = (e, index) => { e.preventDefault(); setDragOverIndex(index); };
          const handleDrop = (e, dropIndex) => {
            e.preventDefault();
            if (draggedCard === null) return;
            const newHand = [...myHand];
            const [removed] = newHand.splice(draggedCard.index, 1);
            newHand.splice(dropIndex, 0, removed);
            setMyHand(newHand); setDraggedCard(null); setDragOverIndex(null);
            sendData({ type: 'hand-reordered' });
          };

          const copyInviteLink = () => {
            navigator.clipboard.writeText(`${window.location.origin}${window.location.pathname}?join=${myPeerId}`);
            setCopied(true); setTimeout(() => setCopied(false), 2000);
          };

          if (gameState === 'setup') {
            return (
              <div className="w-full min-h-screen bg-gradient-to-b from-blue-100 to-blue-200 p-8 flex items-center justify-center">
                <div className="bg-white rounded-lg shadow-xl p-12 max-w-5xl w-full" style={{margin: '3cm'}}>
                  <h1 className="text-4xl font-bold text-center text-blue-600 mb-8">Go-Fish Phonics</h1>
                  {!myPeerId ? (
                    <div className="text-center"><div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div><p className="mt-4 text-gray-600">Connecting...</p></div>
                  ) : (
                    <div className="space-y-6">
                      <div className="grid grid-cols-2 gap-6">
                        <div><label className="block text-sm font-medium text-gray-700 mb-2">Your Name</label><input type="text" value={playerName} onChange={(e) => setPlayerName(e.target.value)} className="w-full px-4 py-2 border border-gray-300 rounded-lg" placeholder="Enter your name" /></div>
                        {isHost && (
                          <div><label className="block text-sm font-medium text-gray-700 mb-2">Turn End Mode</label><select value={settings.endTurnMode} onChange={(e) => setSettings({...settings, endTurnMode: e.target.value})} className="w-full px-4 py-2 border border-gray-300 rounded-lg"><option value="always-draw">Classic Mode</option><option value="manual-end">Strategic Mode</option></select></div>
                        )}
                      </div>
                      {isHost && (
                        <div><label className="block text-sm font-medium text-gray-700 mb-2">Who Goes First?</label><select value={settings.firstPlayer} onChange={(e) => setSettings({...settings, firstPlayer: e.target.value})} className="w-full px-4 py-2 border border-gray-300 rounded-lg"><option value="host">Host (You)</option><option value="opponent">Opponent</option></select></div>
                      )}
                      {isHost && (
                        <div><label className="block text-sm font-medium text-gray-700 mb-2"><Settings size={18} /> Select Card Sets</label><div className="bg-gray-50 p-4 rounded-lg"><div className="grid grid-cols-4 gap-3 text-sm">{Object.entries(SET_NAMES).map(([key, name]) => (<div key={key} className="flex items-center"><input type="checkbox" checked={settings.selectedSets.includes(key)} onChange={(e) => { if (e.target.checked) setSettings({...settings, selectedSets: [...settings.selectedSets, key]}); else setSettings({...settings, selectedSets: settings.selectedSets.filter(s => s !== key)}); }} className="mr-2" />{name}</div>))}</div></div></div>
                      )}
                      {isHost && (
                        <div className="bg-blue-50 border-2 border-blue-300 rounded-lg p-4"><div className="flex items-center justify-between mb-2"><div className="flex items-center gap-2"><Users size={20} /><span className="font-semibold text-blue-900">Invite Opponent</span></div><div className="flex items-center gap-3"><div className="px-3 py-1 bg-white border border-gray-300 rounded text-sm">{connected && opponentName ? opponentName : 'No connection'}</div>{connected ? <span className="text-green-600 text-sm flex items-center gap-1"><Wifi size={16} /> Connected</span> : <span className="text-orange-600 text-sm flex items-center gap-1"><WifiOff size={16} /> Waiting...</span>}</div></div><p className="text-sm text-gray-700 mb-3">Share this link:</p><div className="flex gap-2"><input type="text" value={`${window.location.origin}${window.location.pathname}?join=${myPeerId}`} readOnly className="flex-1 px-3 py-2 bg-white border border-gray-300 rounded text-sm" /><button onClick={copyInviteLink} className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 flex items-center gap-2">{copied ? <Check size={16} /> : <Copy size={16} />}{copied ? 'Copied!' : 'Copy'}</button></div></div>
                      )}
                      {!isHost && (<div className="bg-green-50 border-2 border-green-300 rounded-lg p-4"><p className="text-green-900 font-semibold mb-2">Joining game...</p><p className="text-sm text-gray-700">Click Connect</p>{connected && <p className="text-green-600 text-sm mt-2 flex items-center gap-1"><Wifi size={16} /> Connected! Waiting for host...</p>}</div>)}
                      {isHost ? (<button onClick={startGame} disabled={!connected} className={`w-full py-3 rounded-lg font-semibold ${connected ? 'bg-blue-600 text-white hover:bg-blue-700' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}>{connected ? 'Start Game' : 'Waiting for Opponent...'}</button>) : (<button onClick={connectToOpponent} disabled={connected} className={`w-full py-3 rounded-lg font-semibold ${!connected ? 'bg-green-600 text-white hover:bg-green-700' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}>{connected ? 'Connected - Waiting for Host' : 'Connect to Game'}</button>)}
                    </div>
                  )}
                </div>
              </div>
            );
          }

          return (
            <div className="w-full h-screen bg-gradient-to-b from-green-100 to-green-200 flex flex-col">
              {gameEnded && disconnectMessage && (
                <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                  <div className="bg-white rounded-lg shadow-2xl p-8 max-w-md text-center">
                    <h2 className="text-2xl font-bold text-red-600 mb-4">Game Ended</h2>
                    <p className="text-gray-700 mb-6">{disconnectMessage}</p>
                  </div>
                </div>
              )}
                <div className={`bg-white shadow-md p-4 flex justify-between items-center ${isMyTurn ? 'animate-pulse' : ''}`}><div className="flex items-center gap-4"><div className="text-lg font-semibold text-gray-700">{playerName || 'Your'}'s Hand</div></div><div className="text-xl font-bold">{isMyTurn ? "Your Turn" : `${opponentName || "Opponent"}'s Turn`}</div><div className="flex gap-4"><div className="text-center"><div className="text-sm text-gray-600">{playerName}</div><div className="text-2xl font-bold text-blue-600">{myScore}</div></div><div className="text-center"><div className="text-sm text-gray-600">{opponentName}</div><div className="text-2xl font-bold text-red-600">{opponentScore}</div></div></div></div>              <div className="flex-1 p-4 flex items-start justify-center"><div className="flex gap-2">{Array(opponentHandCount).fill(0).map((_, i) => (<div key={i} className="w-20 h-28 bg-blue-500 rounded-lg shadow-lg border-4 border-blue-700" />))}</div><div className="ml-8 flex gap-2">{opponentSets.map((set, i) => (<div key={i} className="text-center"><div className="text-xs font-semibold mb-1">{SET_NAMES[set.set]}</div><div className="flex gap-1">{set.cards.map((card, j) => (<div key={j} className="w-12 h-16 bg-green-400 rounded border-2 border-green-600 flex items-center justify-center text-xs">{card.name}</div>))}</div></div>))}</div></div>
              <div className="flex justify-center items-center py-4"><div className="text-center"><button onClick={drawCard} disabled={!isMyTurn || deckCount === 0} className={`w-24 h-32 rounded-lg shadow-xl border-4 font-bold text-white text-xl ${deckCount > 0 ? 'bg-purple-600 border-purple-800 hover:bg-purple-700' : 'bg-gray-400 border-gray-600'} ${!isMyTurn || deckCount === 0 ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}`}>{deckCount}</button><div className="text-sm mt-2 font-semibold">Deck</div></div>{settings.endTurnMode === 'manual-end' && (<button onClick={endTurn} disabled={!isMyTurn} className={`ml-8 px-6 py-3 rounded-lg font-semibold ${isMyTurn ? 'bg-orange-500 hover:bg-orange-600 text-white' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}>End Turn</button>)}</div>
              <div className="flex-1 p-4 flex items-end justify-center"><div className="flex gap-2">{myHand.map((card, i) => (<div key={card.id} draggable onDragStart={(e) => handleDragStart(e, card, i)} onDragOver={(e) => handleDragOver(e, i)} onDrop={(e) => handleDrop(e, i)} onClick={() => setSelectedCard(selectedCard?.id === card.id ? null : card)} className={`w-20 h-28 rounded-lg shadow-lg border-4 cursor-pointer relative ${selectedCard?.id === card.id ? 'border-yellow-400 bg-yellow-100' : 'border-white bg-white'} ${dragOverIndex === i ? 'ring-4 ring-blue-400' : ''}`}><div className="p-2 text-center"><div className="text-xs font-semibold text-gray-600">{SET_NAMES[card.set]}</div><div className="text-sm font-bold mt-1">{card.name}</div></div>{selectedCard?.id === card.id && (<button onClick={(e) => { e.stopPropagation(); giveCard(); }} className="absolute -top-8 left-1/2 transform -translate-x-1/2 bg-red-500 text-white rounded-full p-2 hover:bg-red-600"><ArrowUp /></button>)}</div>))}</div><div className="ml-8 flex gap-2">{mySets.map((set, i) => (<div key={i} className="text-center"><div className="text-xs font-semibold mb-1">{SET_NAMES[set.set]}</div><div className="flex gap-1">{set.cards.map((card, j) => (<div key={j} className="w-12 h-16 bg-green-400 rounded border-2 border-green-600 flex items-center justify-center text-xs">{card.name}</div>))}</div></div>))}</div></div>
            </div>
          );
        };

        ReactDOM.render(<GoFishPhonics />, document.getElementById('root'));
    </script>
</body>
</html>













